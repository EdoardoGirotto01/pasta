<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pasta.pasta_parser API documentation</title>
<meta name="description" content="Class defining a parser for a PASTA program." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pasta.pasta_parser</code></h1>
</header>
<section id="section-intro">
<p>Class defining a parser for a PASTA program.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Class defining a parser for a PASTA program.
&#39;&#39;&#39;
import os
import sys
from typing import Union

from utils import print_waring, print_error_and_exit, warning_prob_fact_twice
from generator import Generator


class PastaParser:
    &#39;&#39;&#39;
    Parameters:
        - filename: name of the file to read
        - query: query
        - evidence: evidence
        - lines_original: lines from the parsing of the original file
        - lines_prob: lines obtained by parsing probabilistic facts
        - probabilistic_fact: dictionary containing pairs [probabilistic fact, probability]
        - abducibles: list of abducibles
    &#39;&#39;&#39;

    def __init__(
        self, 
        filename : str, 
        query : str = &#34;&#34;, 
        evidence : str = &#34;&#34;
        ) -&gt; None:
        self.filename : str = filename
        self.query : str = query
        self.evidence : str = evidence
        self.lines_original : list[str] = []
        self.lines_prob : list[str] = []
        self.probabilistic_facts : dict[str,float] = dict() # pairs [fact,prob]
        self.abducibles : list[str] = []
        self.n_probabilistic_ics : int = 0
        self.body_probabilistic_ics : list[str] = []
        self.map_id_list : list[int] = []


    @staticmethod
    def symbol_endline_or_space(char1: str) -&gt; bool:
        return char1 == &#39;\n&#39; or char1 == &#39;\r\n&#39; or char1 == &#39; &#39;


    @staticmethod
    def endline_symbol(char1: str) -&gt; bool:
        return char1 == &#39;\n&#39; or char1 == &#39;\r\n&#39;


    @staticmethod
    def is_number(n: Union[int, float, str]) -&gt; bool:
        try:
            float(n)
        except ValueError:
            return False
        return True


    @staticmethod
    def is_int(n: int) -&gt; bool:
        try:
            int(n)
        except ValueError:
            return False
        return True


    # extracts the functor from a compound term. If the term is an atom
    # returns the atom itself
    @staticmethod
    def get_functor(term: str) -&gt; str:
        r = &#34;&#34;
        i = 0
        while i &lt; len(term) and term[i] != &#39;(&#39;:
            r = r + term[i]
            i = i + 1
        return r


    @staticmethod
    def check_consistent_prob_fact(line_in: str) -&gt; &#39;tuple[float, str]&#39;:
        if not line_in.endswith(&#39;.&#39;):
            sys.exit(&#34;Missing final . in &#34; + line_in)

        line = line_in.split(&#34;::&#34;)
        # for example: line = [&#39;0.5&#39;, &#39;f(1..3).&#39;]
        if len(line) != 2:
            sys.exit(&#34;Error in parsing: &#34; + str(line))

        if not PastaParser.is_number(line[0]):
            print(&#34;---- &#34;)
            sys.exit(&#34;Error: expected a float, found &#34; + str(line[0]))

        prob = float(line[0])

        if prob &gt; 1 or prob &lt; 0:
            sys.exit(&#34;Probabilities must be in the range [0,1], found &#34; + str(prob))

        # [:-1] to remove final .
        term = line[1][:-1]

        if len(term) == 0 or not term[0].islower():
            sys.exit(&#34;Invalid probabilistic fact &#34; + str(term))

        return prob, term


    def parse_approx(self, from_string : str = &#34;&#34;) -&gt; None:
        &#39;&#39;&#39;
        Parses a program into an alternative form: probabilistic 
        facts are converted into external facts
        &#39;&#39;&#39;
        if not from_string and os.path.isfile(self.filename) == False:
            print(&#34;File &#34; + self.filename + &#34; not found&#34;)
            sys.exit()

        if not from_string:
            f = open(self.filename,&#34;r&#34;)
        else:
            import io
            f = io.StringIO(from_string)

        lines = f.readlines()

        for l in lines:
            if not l.startswith(&#39;%&#39;):
                if &#39;::&#39; in l:
                    # probabilistic fact
                    l = l.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;).split(&#39;::&#39;)
                    prob = l[0]
                    term = l[1].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;).replace(&#39;.&#39;,&#39;&#39;)
                    self.probabilistic_facts[term] = float(prob)
                    self.lines_prob.append(f&#39;#external {term}.&#39;)
                elif not l.startswith(&#39;\n&#39;):
                    self.lines_prob.append(l.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;))


    def parse(self, from_string : str = &#34;&#34;) -&gt; None:
        &#39;&#39;&#39;
        Parameters:
            - None
        Returns:
            - list of strings representing the program
        Behavior:
            - parses the file and extract the lines
        &#39;&#39;&#39;
        if not from_string and os.path.isfile(self.filename) == False:
            print(&#34;File &#34; + self.filename + &#34; not found&#34;)
            sys.exit()
        
        if not from_string:
            f = open(self.filename,&#34;r&#34;)
        else:
            import io
            f = io.StringIO(from_string)
        
        char = f.read(1)
        if not char:
            print(&#34;Empty file&#34;)
            sys.exit()

        # eat possible white spaces or empty lines
        while self.symbol_endline_or_space(char):
            char = f.read(1)

        comment = False
        if char == &#39;%&#39;:
            comment = True

        char1 = f.read(1)
        
        while char1:
            l0 = &#34;&#34;
            while char1 and not(((char == &#39;.&#39; and not comment) and self.symbol_endline_or_space(char1)) or (comment and self.endline_symbol(char1))):
                # look for a . followed by \n
                l0 = l0 + char
                char = char1
                char1 = f.read(1)
            # new line
            l0 = l0 + char
            if not comment:
                l0 = l0.replace(&#39;\n&#39;, &#39;&#39;).replace(&#39;\r&#39;, &#39;&#39;)
                if &#34;not &#34; in l0: # to handle not fact, and avoid removing spaces, important space after not
                    l0 = l0.split(&#34;not&#34;)
                    l1 = &#34;&#34;
                    for el in l0:
                        el = el.replace(&#39; &#39;, &#39;&#39;)
                        l1 = l1 + el + &#34; not &#34;
                    l1 = l1[:-4]  # remove last not
                elif l0.startswith(&#39;abducible&#39;):  # abducible facts
                    l0 = l0.split(&#39;abducible&#39;)
                    for i in range(1, len(l0)):
                        l0[i] = l0[i].replace(&#39; &#39;, &#39;&#39;)
                    l1 = &#34;abducible&#34;
                    for i in range(1, len(l0)):
                        l1 = l1 + &#39; &#39; + l0[i]
                    # print(l1)
                elif l0.startswith(&#39;map&#39;):
                    l0 = l0.split(&#39;map&#39;)
                    for i in range(1, len(l0)):
                        l0[i] = l0[i].replace(&#39; &#39;, &#39;&#39;)
                    l1 = &#34;map&#34;
                    for i in range(1, len(l0)):
                        l1 = l1 + &#39; &#39; + l0[i]
                else:
                    l1 = l0.replace(&#39; &#39;,&#39;&#39;)

                if l0[0].startswith(&#39;not_&#39;):
                    print_waring(&#34;The head of a clause that starts with not_ is not suggested.&#34;)
                    print_waring(&#34;Hou should change its name. If not, you may get a wrong probability range&#34;)

                # hack to handle something like: 0.5::a % comment, to remove
                # the part after the %
                percent = l1.find(&#39;%&#39;)
                if percent != -1:
                    l1 = l1[:percent]

                self.lines_original.append(l1)
            char = char1
            # eat white spaces or empty lines
            char1 = f.read(1)
            while self.symbol_endline_or_space(char1):
                char1 = f.read(1)
            if char1 == &#39;%&#39;:
                comment = True
            else:
                comment = False
            # print(char)
            # print(char1)
        f.close()
        self.parse_program()


    def parse_program(self) -&gt; bool:
        &#39;&#39;&#39;
        Second layer of program parsing
        &#39;&#39;&#39;
        n_probabilistic_facts = 0
        gen = Generator()
        for line in self.lines_original:
            self.check_reserved(line)
            if &#34;::&#34; in line and not line.startswith(&#39;%&#39;) and not line.startswith(&#34;map&#34;):
                if &#39;:-&#39; in line:
                    print_error_and_exit(&#34;Probabilistic clauses are not supported\n&#34; + line)
                if &#39;;&#39; in line:
                    print_error_and_exit(
                        &#34;Disjunction is not yet supported in probabilistic facts\nplease rewrite it as single fact.\nExample: 0.6::a;0.2::b. can be written as\n0.6::a. 0.5::b. where 0.5=0.2/(1 - 0.6)&#34;)
                # line with probability value
                probability, fact = self.check_consistent_prob_fact(line)

                self.add_probabilistic_fact(fact,probability)

                # self.lines_prob.append(clauses)

                n_probabilistic_facts = n_probabilistic_facts + 1
            elif line.startswith(&#34;query(&#34;):
                # remove the &#34;query&#34; functor and handles whether the line
                # does not terminate with .
                # query(fly(1)) -&gt; fly(1)
                if line[-1] == &#34;.&#34;:
                    self.query = line.split(&#34;query&#34;)[1][:-2][1:]
                else:
                    self.query = line.split(&#34;query&#34;)[1][:-1][1:]
            elif line.startswith(&#34;evidence(&#34;):
                if line[-1] == &#34;.&#34;:
                    # remove the &#34;evidence&#34; functor and handles whether the line
                    # does not terminate with .
                    # evidence(fly(1)) -&gt; fly(1)
                    self.evidence = line.split(&#34;evidence&#34;)[1][:-2][1:]
                else:
                    self.evidence = line.split(&#34;evidence&#34;)[1][:-1][1:]
            elif line.startswith(&#34;(&#34;):
                expanded_conditional = gen.generate_clauses_for_conditionals(line)
                for el in expanded_conditional:
                    self.lines_prob.append([el])
            elif line.startswith(&#34;abducible&#34;):
                _, abducible = gen.generate_clauses_for_abducibles(line, 0)
                # self.lines_prob.append(clauses)
                # self.abducibles.append(abducible)
                self.abducibles.append(abducible)
            elif line.startswith(&#34;map&#34;):
                # add the MAP fact as probabilistic
                fact = line.split(&#39;map&#39;)[1]
                print(line)
                probability, fact = self.check_consistent_prob_fact(fact)
                self.map_id_list.append(len(self.probabilistic_facts))
                self.add_probabilistic_fact(fact,probability)
            elif self.is_number(line.split(&#39;:-&#39;)[0]):
                # probabilistic IC p:- body.
                # print(&#34;prob ic&#34;)
                # generate the probabilistic fact
                new_line = line.split(&#39;:-&#39;)[0] + &#34;::icf&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
                probability, fact = self.check_consistent_prob_fact(new_line)
                self.add_probabilistic_fact(fact, probability)
                new_clause = &#34;ic&#34; + str(self.n_probabilistic_ics) + &#34;:- &#34; + line.split(&#39;:-&#39;)[1]
                self.lines_prob.append([new_clause])

                new_ic_0 = &#34;:- icf&#34; + str(self.n_probabilistic_ics) + &#34;, ic&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
                self.lines_prob.append([new_ic_0])

                new_ic_1 = &#34;:- not icf&#34; + str(self.n_probabilistic_ics) + &#34;, not ic&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
                self.lines_prob.append([new_ic_1])

                self.n_probabilistic_ics = self.n_probabilistic_ics + 1
                
            else:
                if not line.startswith(&#34;#show&#34;):
                    self.lines_prob.append([line])
        if not self.query:
            print_error_and_exit(&#34;Missing query&#34;)
            
        self.lines_prob = [item for sublist in self.lines_prob for item in sublist]

        for fact in self.probabilistic_facts:
            # To handle 0.1::a. a. q:- a.
            # Without this, the computed prob is 0.1, while the correct
            # prob should be 1.
            if fact + &#39;.&#39; in self.lines_prob:
                self.probabilistic_facts[fact] = 1

            clauses = gen.generate_clauses_for_facts(fact, self.probabilistic_facts[fact])
            for c in clauses:
                self.lines_prob.append(c)

        i = 0
        for abd in self.abducibles:
            # kind of hack, refactor generate_clauses_for abducibles TODO
            clauses, _ = gen.generate_clauses_for_abducibles(&#34;abducible &#34; + abd + &#34;.&#34;, i)
            i = i + 1
            for c in clauses:
                self.lines_prob.append(c)

        # for a in self.lines_prob:
        #     print(a)
        # sys.exit()
        return True


    def check_reserved(self, line : str) -&gt; None:
        &#39;&#39;&#39;
        Dummy check for reserved names (q, nq, e, ne)
        &#39;&#39;&#39;
        if line.startswith(&#39;q:-&#39;):
            print_error_and_exit(&#34;q is a reserved fact&#34;)
        elif line.startswith(&#39;nq:-&#39;):
            print_error_and_exit(&#34;nq is a reserved fact&#34;)
        elif line.startswith(&#39;e:-&#39;):
            print_error_and_exit(&#34;e is a reserved fact&#34;)
        elif line.startswith(&#39;ne:-&#39;):
            print_error_and_exit(&#34;ne is a reserved fact&#34;)


    def get_content_to_compute_minimal_set_facts(self) -&gt; &#39;list[str]&#39;:
        &#39;&#39;&#39;
        Parameters:
            - None
        Returns:
            - str: program used to compute the minimal set of probabilistic
            facts to make the query true
        Behavior:
            generate the file to pass to ASP to compute the minimal set
            of probabilistic facts to make the query true
        &#39;&#39;&#39;
        if self.evidence == &#34;&#34;:
            prog = self.lines_prob + [&#34;:- not &#34; + self.query + &#34;.&#34;]
        else:
            prog = self.lines_prob + [&#34;:- not &#34; + self.evidence + &#34;.&#34;]
        
        return prog


    def get_asp_program(self) -&gt; &#39;list[str]&#39;:
        &#39;&#39;&#39;
        Parameters:
            - None
        Returns:
            - str: string representing the program that can be used to 
            compute lower and upper probability
        Behavior:
            returns a string that represent the ASP program where models 
            need to be computed
        &#39;&#39;&#39;
        self.lines_prob.append(f&#34;q:- {self.query}.&#34;)
        self.lines_prob.append(&#34;#show q/0.&#34;)
        self.lines_prob.append(f&#34;nq:- not {self.query}.&#34;)
        self.lines_prob.append(&#34;#show nq/0.&#34;)

        if self.evidence:
            self.lines_prob.append(f&#34;e:- {self.evidence}.&#34;)
            self.lines_prob.append(&#34;#show e/0.&#34;)
            self.lines_prob.append(f&#34;ne:- not {self.evidence}.&#34;)
            self.lines_prob.append(&#34;#show ne/0.&#34;)

        return self.lines_prob


    def add_probabilistic_fact(self, term : str, prob : float) -&gt; None:
        &#39;&#39;&#39;
        Adds the current probabilistic fact and its probability in the 
        list of probabilistic facts
        &#39;&#39;&#39;
        key = term.split(&#39;.&#39;)[0]
        if key in self.probabilistic_facts:
            warning_prob_fact_twice(
                key, prob, self.probabilistic_facts[key])
            sys.exit()
        self.probabilistic_facts[key] = float(prob)


    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;
        String representation of the current class
        &#39;&#39;&#39;
        return &#34;filename: &#34; + self.filename + &#34;\n&#34; + \
        &#34;query: &#34; + str(self.query) + &#34;\n&#34; + \
        ((&#34;evidence: &#34; + str(self.evidence) + &#34;\n&#34;) if self.evidence else &#34;&#34;) + \
        &#34;probabilistic facts:\n&#34; + str([str(x) + &#34; &#34; + str(y) for x, y in self.probabilistic_facts.items()]) + &#34;\n&#34; + \
        &#34;n probabilistic facts:\n&#34; + str(self.probabilistic_facts) + &#34;\n&#34; + \
        &#34;original file:\n&#34; + str(self.lines_original) + &#34;\n&#34; + \
        &#34;probabilities file:\n&#34; + str(self.lines_prob) + &#34;\n&#34; + \
        ((&#34;abducibles: &#34; + str(self.abducibles))  if len(self.abducibles) &gt; 0 else &#34;&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pasta.pasta_parser.PastaParser"><code class="flex name class">
<span>class <span class="ident">PastaParser</span></span>
<span>(</span><span>filename: str, query: str = '', evidence: str = '')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li>filename: name of the file to read</li>
<li>query: query</li>
<li>evidence: evidence</li>
<li>lines_original: lines from the parsing of the original file</li>
<li>lines_prob: lines obtained by parsing probabilistic facts</li>
<li>probabilistic_fact: dictionary containing pairs [probabilistic fact, probability]</li>
<li>abducibles: list of abducibles</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PastaParser:
    &#39;&#39;&#39;
    Parameters:
        - filename: name of the file to read
        - query: query
        - evidence: evidence
        - lines_original: lines from the parsing of the original file
        - lines_prob: lines obtained by parsing probabilistic facts
        - probabilistic_fact: dictionary containing pairs [probabilistic fact, probability]
        - abducibles: list of abducibles
    &#39;&#39;&#39;

    def __init__(
        self, 
        filename : str, 
        query : str = &#34;&#34;, 
        evidence : str = &#34;&#34;
        ) -&gt; None:
        self.filename : str = filename
        self.query : str = query
        self.evidence : str = evidence
        self.lines_original : list[str] = []
        self.lines_prob : list[str] = []
        self.probabilistic_facts : dict[str,float] = dict() # pairs [fact,prob]
        self.abducibles : list[str] = []
        self.n_probabilistic_ics : int = 0
        self.body_probabilistic_ics : list[str] = []
        self.map_id_list : list[int] = []


    @staticmethod
    def symbol_endline_or_space(char1: str) -&gt; bool:
        return char1 == &#39;\n&#39; or char1 == &#39;\r\n&#39; or char1 == &#39; &#39;


    @staticmethod
    def endline_symbol(char1: str) -&gt; bool:
        return char1 == &#39;\n&#39; or char1 == &#39;\r\n&#39;


    @staticmethod
    def is_number(n: Union[int, float, str]) -&gt; bool:
        try:
            float(n)
        except ValueError:
            return False
        return True


    @staticmethod
    def is_int(n: int) -&gt; bool:
        try:
            int(n)
        except ValueError:
            return False
        return True


    # extracts the functor from a compound term. If the term is an atom
    # returns the atom itself
    @staticmethod
    def get_functor(term: str) -&gt; str:
        r = &#34;&#34;
        i = 0
        while i &lt; len(term) and term[i] != &#39;(&#39;:
            r = r + term[i]
            i = i + 1
        return r


    @staticmethod
    def check_consistent_prob_fact(line_in: str) -&gt; &#39;tuple[float, str]&#39;:
        if not line_in.endswith(&#39;.&#39;):
            sys.exit(&#34;Missing final . in &#34; + line_in)

        line = line_in.split(&#34;::&#34;)
        # for example: line = [&#39;0.5&#39;, &#39;f(1..3).&#39;]
        if len(line) != 2:
            sys.exit(&#34;Error in parsing: &#34; + str(line))

        if not PastaParser.is_number(line[0]):
            print(&#34;---- &#34;)
            sys.exit(&#34;Error: expected a float, found &#34; + str(line[0]))

        prob = float(line[0])

        if prob &gt; 1 or prob &lt; 0:
            sys.exit(&#34;Probabilities must be in the range [0,1], found &#34; + str(prob))

        # [:-1] to remove final .
        term = line[1][:-1]

        if len(term) == 0 or not term[0].islower():
            sys.exit(&#34;Invalid probabilistic fact &#34; + str(term))

        return prob, term


    def parse_approx(self, from_string : str = &#34;&#34;) -&gt; None:
        &#39;&#39;&#39;
        Parses a program into an alternative form: probabilistic 
        facts are converted into external facts
        &#39;&#39;&#39;
        if not from_string and os.path.isfile(self.filename) == False:
            print(&#34;File &#34; + self.filename + &#34; not found&#34;)
            sys.exit()

        if not from_string:
            f = open(self.filename,&#34;r&#34;)
        else:
            import io
            f = io.StringIO(from_string)

        lines = f.readlines()

        for l in lines:
            if not l.startswith(&#39;%&#39;):
                if &#39;::&#39; in l:
                    # probabilistic fact
                    l = l.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;).split(&#39;::&#39;)
                    prob = l[0]
                    term = l[1].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;).replace(&#39;.&#39;,&#39;&#39;)
                    self.probabilistic_facts[term] = float(prob)
                    self.lines_prob.append(f&#39;#external {term}.&#39;)
                elif not l.startswith(&#39;\n&#39;):
                    self.lines_prob.append(l.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;))


    def parse(self, from_string : str = &#34;&#34;) -&gt; None:
        &#39;&#39;&#39;
        Parameters:
            - None
        Returns:
            - list of strings representing the program
        Behavior:
            - parses the file and extract the lines
        &#39;&#39;&#39;
        if not from_string and os.path.isfile(self.filename) == False:
            print(&#34;File &#34; + self.filename + &#34; not found&#34;)
            sys.exit()
        
        if not from_string:
            f = open(self.filename,&#34;r&#34;)
        else:
            import io
            f = io.StringIO(from_string)
        
        char = f.read(1)
        if not char:
            print(&#34;Empty file&#34;)
            sys.exit()

        # eat possible white spaces or empty lines
        while self.symbol_endline_or_space(char):
            char = f.read(1)

        comment = False
        if char == &#39;%&#39;:
            comment = True

        char1 = f.read(1)
        
        while char1:
            l0 = &#34;&#34;
            while char1 and not(((char == &#39;.&#39; and not comment) and self.symbol_endline_or_space(char1)) or (comment and self.endline_symbol(char1))):
                # look for a . followed by \n
                l0 = l0 + char
                char = char1
                char1 = f.read(1)
            # new line
            l0 = l0 + char
            if not comment:
                l0 = l0.replace(&#39;\n&#39;, &#39;&#39;).replace(&#39;\r&#39;, &#39;&#39;)
                if &#34;not &#34; in l0: # to handle not fact, and avoid removing spaces, important space after not
                    l0 = l0.split(&#34;not&#34;)
                    l1 = &#34;&#34;
                    for el in l0:
                        el = el.replace(&#39; &#39;, &#39;&#39;)
                        l1 = l1 + el + &#34; not &#34;
                    l1 = l1[:-4]  # remove last not
                elif l0.startswith(&#39;abducible&#39;):  # abducible facts
                    l0 = l0.split(&#39;abducible&#39;)
                    for i in range(1, len(l0)):
                        l0[i] = l0[i].replace(&#39; &#39;, &#39;&#39;)
                    l1 = &#34;abducible&#34;
                    for i in range(1, len(l0)):
                        l1 = l1 + &#39; &#39; + l0[i]
                    # print(l1)
                elif l0.startswith(&#39;map&#39;):
                    l0 = l0.split(&#39;map&#39;)
                    for i in range(1, len(l0)):
                        l0[i] = l0[i].replace(&#39; &#39;, &#39;&#39;)
                    l1 = &#34;map&#34;
                    for i in range(1, len(l0)):
                        l1 = l1 + &#39; &#39; + l0[i]
                else:
                    l1 = l0.replace(&#39; &#39;,&#39;&#39;)

                if l0[0].startswith(&#39;not_&#39;):
                    print_waring(&#34;The head of a clause that starts with not_ is not suggested.&#34;)
                    print_waring(&#34;Hou should change its name. If not, you may get a wrong probability range&#34;)

                # hack to handle something like: 0.5::a % comment, to remove
                # the part after the %
                percent = l1.find(&#39;%&#39;)
                if percent != -1:
                    l1 = l1[:percent]

                self.lines_original.append(l1)
            char = char1
            # eat white spaces or empty lines
            char1 = f.read(1)
            while self.symbol_endline_or_space(char1):
                char1 = f.read(1)
            if char1 == &#39;%&#39;:
                comment = True
            else:
                comment = False
            # print(char)
            # print(char1)
        f.close()
        self.parse_program()


    def parse_program(self) -&gt; bool:
        &#39;&#39;&#39;
        Second layer of program parsing
        &#39;&#39;&#39;
        n_probabilistic_facts = 0
        gen = Generator()
        for line in self.lines_original:
            self.check_reserved(line)
            if &#34;::&#34; in line and not line.startswith(&#39;%&#39;) and not line.startswith(&#34;map&#34;):
                if &#39;:-&#39; in line:
                    print_error_and_exit(&#34;Probabilistic clauses are not supported\n&#34; + line)
                if &#39;;&#39; in line:
                    print_error_and_exit(
                        &#34;Disjunction is not yet supported in probabilistic facts\nplease rewrite it as single fact.\nExample: 0.6::a;0.2::b. can be written as\n0.6::a. 0.5::b. where 0.5=0.2/(1 - 0.6)&#34;)
                # line with probability value
                probability, fact = self.check_consistent_prob_fact(line)

                self.add_probabilistic_fact(fact,probability)

                # self.lines_prob.append(clauses)

                n_probabilistic_facts = n_probabilistic_facts + 1
            elif line.startswith(&#34;query(&#34;):
                # remove the &#34;query&#34; functor and handles whether the line
                # does not terminate with .
                # query(fly(1)) -&gt; fly(1)
                if line[-1] == &#34;.&#34;:
                    self.query = line.split(&#34;query&#34;)[1][:-2][1:]
                else:
                    self.query = line.split(&#34;query&#34;)[1][:-1][1:]
            elif line.startswith(&#34;evidence(&#34;):
                if line[-1] == &#34;.&#34;:
                    # remove the &#34;evidence&#34; functor and handles whether the line
                    # does not terminate with .
                    # evidence(fly(1)) -&gt; fly(1)
                    self.evidence = line.split(&#34;evidence&#34;)[1][:-2][1:]
                else:
                    self.evidence = line.split(&#34;evidence&#34;)[1][:-1][1:]
            elif line.startswith(&#34;(&#34;):
                expanded_conditional = gen.generate_clauses_for_conditionals(line)
                for el in expanded_conditional:
                    self.lines_prob.append([el])
            elif line.startswith(&#34;abducible&#34;):
                _, abducible = gen.generate_clauses_for_abducibles(line, 0)
                # self.lines_prob.append(clauses)
                # self.abducibles.append(abducible)
                self.abducibles.append(abducible)
            elif line.startswith(&#34;map&#34;):
                # add the MAP fact as probabilistic
                fact = line.split(&#39;map&#39;)[1]
                print(line)
                probability, fact = self.check_consistent_prob_fact(fact)
                self.map_id_list.append(len(self.probabilistic_facts))
                self.add_probabilistic_fact(fact,probability)
            elif self.is_number(line.split(&#39;:-&#39;)[0]):
                # probabilistic IC p:- body.
                # print(&#34;prob ic&#34;)
                # generate the probabilistic fact
                new_line = line.split(&#39;:-&#39;)[0] + &#34;::icf&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
                probability, fact = self.check_consistent_prob_fact(new_line)
                self.add_probabilistic_fact(fact, probability)
                new_clause = &#34;ic&#34; + str(self.n_probabilistic_ics) + &#34;:- &#34; + line.split(&#39;:-&#39;)[1]
                self.lines_prob.append([new_clause])

                new_ic_0 = &#34;:- icf&#34; + str(self.n_probabilistic_ics) + &#34;, ic&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
                self.lines_prob.append([new_ic_0])

                new_ic_1 = &#34;:- not icf&#34; + str(self.n_probabilistic_ics) + &#34;, not ic&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
                self.lines_prob.append([new_ic_1])

                self.n_probabilistic_ics = self.n_probabilistic_ics + 1
                
            else:
                if not line.startswith(&#34;#show&#34;):
                    self.lines_prob.append([line])
        if not self.query:
            print_error_and_exit(&#34;Missing query&#34;)
            
        self.lines_prob = [item for sublist in self.lines_prob for item in sublist]

        for fact in self.probabilistic_facts:
            # To handle 0.1::a. a. q:- a.
            # Without this, the computed prob is 0.1, while the correct
            # prob should be 1.
            if fact + &#39;.&#39; in self.lines_prob:
                self.probabilistic_facts[fact] = 1

            clauses = gen.generate_clauses_for_facts(fact, self.probabilistic_facts[fact])
            for c in clauses:
                self.lines_prob.append(c)

        i = 0
        for abd in self.abducibles:
            # kind of hack, refactor generate_clauses_for abducibles TODO
            clauses, _ = gen.generate_clauses_for_abducibles(&#34;abducible &#34; + abd + &#34;.&#34;, i)
            i = i + 1
            for c in clauses:
                self.lines_prob.append(c)

        # for a in self.lines_prob:
        #     print(a)
        # sys.exit()
        return True


    def check_reserved(self, line : str) -&gt; None:
        &#39;&#39;&#39;
        Dummy check for reserved names (q, nq, e, ne)
        &#39;&#39;&#39;
        if line.startswith(&#39;q:-&#39;):
            print_error_and_exit(&#34;q is a reserved fact&#34;)
        elif line.startswith(&#39;nq:-&#39;):
            print_error_and_exit(&#34;nq is a reserved fact&#34;)
        elif line.startswith(&#39;e:-&#39;):
            print_error_and_exit(&#34;e is a reserved fact&#34;)
        elif line.startswith(&#39;ne:-&#39;):
            print_error_and_exit(&#34;ne is a reserved fact&#34;)


    def get_content_to_compute_minimal_set_facts(self) -&gt; &#39;list[str]&#39;:
        &#39;&#39;&#39;
        Parameters:
            - None
        Returns:
            - str: program used to compute the minimal set of probabilistic
            facts to make the query true
        Behavior:
            generate the file to pass to ASP to compute the minimal set
            of probabilistic facts to make the query true
        &#39;&#39;&#39;
        if self.evidence == &#34;&#34;:
            prog = self.lines_prob + [&#34;:- not &#34; + self.query + &#34;.&#34;]
        else:
            prog = self.lines_prob + [&#34;:- not &#34; + self.evidence + &#34;.&#34;]
        
        return prog


    def get_asp_program(self) -&gt; &#39;list[str]&#39;:
        &#39;&#39;&#39;
        Parameters:
            - None
        Returns:
            - str: string representing the program that can be used to 
            compute lower and upper probability
        Behavior:
            returns a string that represent the ASP program where models 
            need to be computed
        &#39;&#39;&#39;
        self.lines_prob.append(f&#34;q:- {self.query}.&#34;)
        self.lines_prob.append(&#34;#show q/0.&#34;)
        self.lines_prob.append(f&#34;nq:- not {self.query}.&#34;)
        self.lines_prob.append(&#34;#show nq/0.&#34;)

        if self.evidence:
            self.lines_prob.append(f&#34;e:- {self.evidence}.&#34;)
            self.lines_prob.append(&#34;#show e/0.&#34;)
            self.lines_prob.append(f&#34;ne:- not {self.evidence}.&#34;)
            self.lines_prob.append(&#34;#show ne/0.&#34;)

        return self.lines_prob


    def add_probabilistic_fact(self, term : str, prob : float) -&gt; None:
        &#39;&#39;&#39;
        Adds the current probabilistic fact and its probability in the 
        list of probabilistic facts
        &#39;&#39;&#39;
        key = term.split(&#39;.&#39;)[0]
        if key in self.probabilistic_facts:
            warning_prob_fact_twice(
                key, prob, self.probabilistic_facts[key])
            sys.exit()
        self.probabilistic_facts[key] = float(prob)


    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;
        String representation of the current class
        &#39;&#39;&#39;
        return &#34;filename: &#34; + self.filename + &#34;\n&#34; + \
        &#34;query: &#34; + str(self.query) + &#34;\n&#34; + \
        ((&#34;evidence: &#34; + str(self.evidence) + &#34;\n&#34;) if self.evidence else &#34;&#34;) + \
        &#34;probabilistic facts:\n&#34; + str([str(x) + &#34; &#34; + str(y) for x, y in self.probabilistic_facts.items()]) + &#34;\n&#34; + \
        &#34;n probabilistic facts:\n&#34; + str(self.probabilistic_facts) + &#34;\n&#34; + \
        &#34;original file:\n&#34; + str(self.lines_original) + &#34;\n&#34; + \
        &#34;probabilities file:\n&#34; + str(self.lines_prob) + &#34;\n&#34; + \
        ((&#34;abducibles: &#34; + str(self.abducibles))  if len(self.abducibles) &gt; 0 else &#34;&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pasta.pasta_parser.PastaParser.check_consistent_prob_fact"><code class="name flex">
<span>def <span class="ident">check_consistent_prob_fact</span></span>(<span>line_in: str) ‑> tuple[float, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def check_consistent_prob_fact(line_in: str) -&gt; &#39;tuple[float, str]&#39;:
    if not line_in.endswith(&#39;.&#39;):
        sys.exit(&#34;Missing final . in &#34; + line_in)

    line = line_in.split(&#34;::&#34;)
    # for example: line = [&#39;0.5&#39;, &#39;f(1..3).&#39;]
    if len(line) != 2:
        sys.exit(&#34;Error in parsing: &#34; + str(line))

    if not PastaParser.is_number(line[0]):
        print(&#34;---- &#34;)
        sys.exit(&#34;Error: expected a float, found &#34; + str(line[0]))

    prob = float(line[0])

    if prob &gt; 1 or prob &lt; 0:
        sys.exit(&#34;Probabilities must be in the range [0,1], found &#34; + str(prob))

    # [:-1] to remove final .
    term = line[1][:-1]

    if len(term) == 0 or not term[0].islower():
        sys.exit(&#34;Invalid probabilistic fact &#34; + str(term))

    return prob, term</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.endline_symbol"><code class="name flex">
<span>def <span class="ident">endline_symbol</span></span>(<span>char1: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def endline_symbol(char1: str) -&gt; bool:
    return char1 == &#39;\n&#39; or char1 == &#39;\r\n&#39;</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.get_functor"><code class="name flex">
<span>def <span class="ident">get_functor</span></span>(<span>term: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_functor(term: str) -&gt; str:
    r = &#34;&#34;
    i = 0
    while i &lt; len(term) and term[i] != &#39;(&#39;:
        r = r + term[i]
        i = i + 1
    return r</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.is_int"><code class="name flex">
<span>def <span class="ident">is_int</span></span>(<span>n: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_int(n: int) -&gt; bool:
    try:
        int(n)
    except ValueError:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.is_number"><code class="name flex">
<span>def <span class="ident">is_number</span></span>(<span>n: Union[int, float, str]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_number(n: Union[int, float, str]) -&gt; bool:
    try:
        float(n)
    except ValueError:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.symbol_endline_or_space"><code class="name flex">
<span>def <span class="ident">symbol_endline_or_space</span></span>(<span>char1: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def symbol_endline_or_space(char1: str) -&gt; bool:
    return char1 == &#39;\n&#39; or char1 == &#39;\r\n&#39; or char1 == &#39; &#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pasta.pasta_parser.PastaParser.add_probabilistic_fact"><code class="name flex">
<span>def <span class="ident">add_probabilistic_fact</span></span>(<span>self, term: str, prob: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the current probabilistic fact and its probability in the
list of probabilistic facts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_probabilistic_fact(self, term : str, prob : float) -&gt; None:
    &#39;&#39;&#39;
    Adds the current probabilistic fact and its probability in the 
    list of probabilistic facts
    &#39;&#39;&#39;
    key = term.split(&#39;.&#39;)[0]
    if key in self.probabilistic_facts:
        warning_prob_fact_twice(
            key, prob, self.probabilistic_facts[key])
        sys.exit()
    self.probabilistic_facts[key] = float(prob)</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.check_reserved"><code class="name flex">
<span>def <span class="ident">check_reserved</span></span>(<span>self, line: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dummy check for reserved names (q, nq, e, ne)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_reserved(self, line : str) -&gt; None:
    &#39;&#39;&#39;
    Dummy check for reserved names (q, nq, e, ne)
    &#39;&#39;&#39;
    if line.startswith(&#39;q:-&#39;):
        print_error_and_exit(&#34;q is a reserved fact&#34;)
    elif line.startswith(&#39;nq:-&#39;):
        print_error_and_exit(&#34;nq is a reserved fact&#34;)
    elif line.startswith(&#39;e:-&#39;):
        print_error_and_exit(&#34;e is a reserved fact&#34;)
    elif line.startswith(&#39;ne:-&#39;):
        print_error_and_exit(&#34;ne is a reserved fact&#34;)</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.get_asp_program"><code class="name flex">
<span>def <span class="ident">get_asp_program</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li>None</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>str: string representing the program that can be used to
compute lower and upper probability</li>
</ul>
<h2 id="behavior">Behavior</h2>
<p>returns a string that represent the ASP program where models
need to be computed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_asp_program(self) -&gt; &#39;list[str]&#39;:
    &#39;&#39;&#39;
    Parameters:
        - None
    Returns:
        - str: string representing the program that can be used to 
        compute lower and upper probability
    Behavior:
        returns a string that represent the ASP program where models 
        need to be computed
    &#39;&#39;&#39;
    self.lines_prob.append(f&#34;q:- {self.query}.&#34;)
    self.lines_prob.append(&#34;#show q/0.&#34;)
    self.lines_prob.append(f&#34;nq:- not {self.query}.&#34;)
    self.lines_prob.append(&#34;#show nq/0.&#34;)

    if self.evidence:
        self.lines_prob.append(f&#34;e:- {self.evidence}.&#34;)
        self.lines_prob.append(&#34;#show e/0.&#34;)
        self.lines_prob.append(f&#34;ne:- not {self.evidence}.&#34;)
        self.lines_prob.append(&#34;#show ne/0.&#34;)

    return self.lines_prob</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.get_content_to_compute_minimal_set_facts"><code class="name flex">
<span>def <span class="ident">get_content_to_compute_minimal_set_facts</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li>None</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>str: program used to compute the minimal set of probabilistic
facts to make the query true</li>
</ul>
<h2 id="behavior">Behavior</h2>
<p>generate the file to pass to ASP to compute the minimal set
of probabilistic facts to make the query true</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_to_compute_minimal_set_facts(self) -&gt; &#39;list[str]&#39;:
    &#39;&#39;&#39;
    Parameters:
        - None
    Returns:
        - str: program used to compute the minimal set of probabilistic
        facts to make the query true
    Behavior:
        generate the file to pass to ASP to compute the minimal set
        of probabilistic facts to make the query true
    &#39;&#39;&#39;
    if self.evidence == &#34;&#34;:
        prog = self.lines_prob + [&#34;:- not &#34; + self.query + &#34;.&#34;]
    else:
        prog = self.lines_prob + [&#34;:- not &#34; + self.evidence + &#34;.&#34;]
    
    return prog</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, from_string: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li>None</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>list of strings representing the program</li>
</ul>
<h2 id="behavior">Behavior</h2>
<ul>
<li>parses the file and extract the lines</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, from_string : str = &#34;&#34;) -&gt; None:
    &#39;&#39;&#39;
    Parameters:
        - None
    Returns:
        - list of strings representing the program
    Behavior:
        - parses the file and extract the lines
    &#39;&#39;&#39;
    if not from_string and os.path.isfile(self.filename) == False:
        print(&#34;File &#34; + self.filename + &#34; not found&#34;)
        sys.exit()
    
    if not from_string:
        f = open(self.filename,&#34;r&#34;)
    else:
        import io
        f = io.StringIO(from_string)
    
    char = f.read(1)
    if not char:
        print(&#34;Empty file&#34;)
        sys.exit()

    # eat possible white spaces or empty lines
    while self.symbol_endline_or_space(char):
        char = f.read(1)

    comment = False
    if char == &#39;%&#39;:
        comment = True

    char1 = f.read(1)
    
    while char1:
        l0 = &#34;&#34;
        while char1 and not(((char == &#39;.&#39; and not comment) and self.symbol_endline_or_space(char1)) or (comment and self.endline_symbol(char1))):
            # look for a . followed by \n
            l0 = l0 + char
            char = char1
            char1 = f.read(1)
        # new line
        l0 = l0 + char
        if not comment:
            l0 = l0.replace(&#39;\n&#39;, &#39;&#39;).replace(&#39;\r&#39;, &#39;&#39;)
            if &#34;not &#34; in l0: # to handle not fact, and avoid removing spaces, important space after not
                l0 = l0.split(&#34;not&#34;)
                l1 = &#34;&#34;
                for el in l0:
                    el = el.replace(&#39; &#39;, &#39;&#39;)
                    l1 = l1 + el + &#34; not &#34;
                l1 = l1[:-4]  # remove last not
            elif l0.startswith(&#39;abducible&#39;):  # abducible facts
                l0 = l0.split(&#39;abducible&#39;)
                for i in range(1, len(l0)):
                    l0[i] = l0[i].replace(&#39; &#39;, &#39;&#39;)
                l1 = &#34;abducible&#34;
                for i in range(1, len(l0)):
                    l1 = l1 + &#39; &#39; + l0[i]
                # print(l1)
            elif l0.startswith(&#39;map&#39;):
                l0 = l0.split(&#39;map&#39;)
                for i in range(1, len(l0)):
                    l0[i] = l0[i].replace(&#39; &#39;, &#39;&#39;)
                l1 = &#34;map&#34;
                for i in range(1, len(l0)):
                    l1 = l1 + &#39; &#39; + l0[i]
            else:
                l1 = l0.replace(&#39; &#39;,&#39;&#39;)

            if l0[0].startswith(&#39;not_&#39;):
                print_waring(&#34;The head of a clause that starts with not_ is not suggested.&#34;)
                print_waring(&#34;Hou should change its name. If not, you may get a wrong probability range&#34;)

            # hack to handle something like: 0.5::a % comment, to remove
            # the part after the %
            percent = l1.find(&#39;%&#39;)
            if percent != -1:
                l1 = l1[:percent]

            self.lines_original.append(l1)
        char = char1
        # eat white spaces or empty lines
        char1 = f.read(1)
        while self.symbol_endline_or_space(char1):
            char1 = f.read(1)
        if char1 == &#39;%&#39;:
            comment = True
        else:
            comment = False
        # print(char)
        # print(char1)
    f.close()
    self.parse_program()</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.parse_approx"><code class="name flex">
<span>def <span class="ident">parse_approx</span></span>(<span>self, from_string: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a program into an alternative form: probabilistic
facts are converted into external facts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_approx(self, from_string : str = &#34;&#34;) -&gt; None:
    &#39;&#39;&#39;
    Parses a program into an alternative form: probabilistic 
    facts are converted into external facts
    &#39;&#39;&#39;
    if not from_string and os.path.isfile(self.filename) == False:
        print(&#34;File &#34; + self.filename + &#34; not found&#34;)
        sys.exit()

    if not from_string:
        f = open(self.filename,&#34;r&#34;)
    else:
        import io
        f = io.StringIO(from_string)

    lines = f.readlines()

    for l in lines:
        if not l.startswith(&#39;%&#39;):
            if &#39;::&#39; in l:
                # probabilistic fact
                l = l.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\t&#39;,&#39;&#39;).split(&#39;::&#39;)
                prob = l[0]
                term = l[1].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;).replace(&#39;.&#39;,&#39;&#39;)
                self.probabilistic_facts[term] = float(prob)
                self.lines_prob.append(f&#39;#external {term}.&#39;)
            elif not l.startswith(&#39;\n&#39;):
                self.lines_prob.append(l.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;))</code></pre>
</details>
</dd>
<dt id="pasta.pasta_parser.PastaParser.parse_program"><code class="name flex">
<span>def <span class="ident">parse_program</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Second layer of program parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_program(self) -&gt; bool:
    &#39;&#39;&#39;
    Second layer of program parsing
    &#39;&#39;&#39;
    n_probabilistic_facts = 0
    gen = Generator()
    for line in self.lines_original:
        self.check_reserved(line)
        if &#34;::&#34; in line and not line.startswith(&#39;%&#39;) and not line.startswith(&#34;map&#34;):
            if &#39;:-&#39; in line:
                print_error_and_exit(&#34;Probabilistic clauses are not supported\n&#34; + line)
            if &#39;;&#39; in line:
                print_error_and_exit(
                    &#34;Disjunction is not yet supported in probabilistic facts\nplease rewrite it as single fact.\nExample: 0.6::a;0.2::b. can be written as\n0.6::a. 0.5::b. where 0.5=0.2/(1 - 0.6)&#34;)
            # line with probability value
            probability, fact = self.check_consistent_prob_fact(line)

            self.add_probabilistic_fact(fact,probability)

            # self.lines_prob.append(clauses)

            n_probabilistic_facts = n_probabilistic_facts + 1
        elif line.startswith(&#34;query(&#34;):
            # remove the &#34;query&#34; functor and handles whether the line
            # does not terminate with .
            # query(fly(1)) -&gt; fly(1)
            if line[-1] == &#34;.&#34;:
                self.query = line.split(&#34;query&#34;)[1][:-2][1:]
            else:
                self.query = line.split(&#34;query&#34;)[1][:-1][1:]
        elif line.startswith(&#34;evidence(&#34;):
            if line[-1] == &#34;.&#34;:
                # remove the &#34;evidence&#34; functor and handles whether the line
                # does not terminate with .
                # evidence(fly(1)) -&gt; fly(1)
                self.evidence = line.split(&#34;evidence&#34;)[1][:-2][1:]
            else:
                self.evidence = line.split(&#34;evidence&#34;)[1][:-1][1:]
        elif line.startswith(&#34;(&#34;):
            expanded_conditional = gen.generate_clauses_for_conditionals(line)
            for el in expanded_conditional:
                self.lines_prob.append([el])
        elif line.startswith(&#34;abducible&#34;):
            _, abducible = gen.generate_clauses_for_abducibles(line, 0)
            # self.lines_prob.append(clauses)
            # self.abducibles.append(abducible)
            self.abducibles.append(abducible)
        elif line.startswith(&#34;map&#34;):
            # add the MAP fact as probabilistic
            fact = line.split(&#39;map&#39;)[1]
            print(line)
            probability, fact = self.check_consistent_prob_fact(fact)
            self.map_id_list.append(len(self.probabilistic_facts))
            self.add_probabilistic_fact(fact,probability)
        elif self.is_number(line.split(&#39;:-&#39;)[0]):
            # probabilistic IC p:- body.
            # print(&#34;prob ic&#34;)
            # generate the probabilistic fact
            new_line = line.split(&#39;:-&#39;)[0] + &#34;::icf&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
            probability, fact = self.check_consistent_prob_fact(new_line)
            self.add_probabilistic_fact(fact, probability)
            new_clause = &#34;ic&#34; + str(self.n_probabilistic_ics) + &#34;:- &#34; + line.split(&#39;:-&#39;)[1]
            self.lines_prob.append([new_clause])

            new_ic_0 = &#34;:- icf&#34; + str(self.n_probabilistic_ics) + &#34;, ic&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
            self.lines_prob.append([new_ic_0])

            new_ic_1 = &#34;:- not icf&#34; + str(self.n_probabilistic_ics) + &#34;, not ic&#34; + str(self.n_probabilistic_ics) + &#34;.&#34;
            self.lines_prob.append([new_ic_1])

            self.n_probabilistic_ics = self.n_probabilistic_ics + 1
            
        else:
            if not line.startswith(&#34;#show&#34;):
                self.lines_prob.append([line])
    if not self.query:
        print_error_and_exit(&#34;Missing query&#34;)
        
    self.lines_prob = [item for sublist in self.lines_prob for item in sublist]

    for fact in self.probabilistic_facts:
        # To handle 0.1::a. a. q:- a.
        # Without this, the computed prob is 0.1, while the correct
        # prob should be 1.
        if fact + &#39;.&#39; in self.lines_prob:
            self.probabilistic_facts[fact] = 1

        clauses = gen.generate_clauses_for_facts(fact, self.probabilistic_facts[fact])
        for c in clauses:
            self.lines_prob.append(c)

    i = 0
    for abd in self.abducibles:
        # kind of hack, refactor generate_clauses_for abducibles TODO
        clauses, _ = gen.generate_clauses_for_abducibles(&#34;abducible &#34; + abd + &#34;.&#34;, i)
        i = i + 1
        for c in clauses:
            self.lines_prob.append(c)

    # for a in self.lines_prob:
    #     print(a)
    # sys.exit()
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pasta" href="index.html">pasta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pasta.pasta_parser.PastaParser" href="#pasta.pasta_parser.PastaParser">PastaParser</a></code></h4>
<ul class="">
<li><code><a title="pasta.pasta_parser.PastaParser.add_probabilistic_fact" href="#pasta.pasta_parser.PastaParser.add_probabilistic_fact">add_probabilistic_fact</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.check_consistent_prob_fact" href="#pasta.pasta_parser.PastaParser.check_consistent_prob_fact">check_consistent_prob_fact</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.check_reserved" href="#pasta.pasta_parser.PastaParser.check_reserved">check_reserved</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.endline_symbol" href="#pasta.pasta_parser.PastaParser.endline_symbol">endline_symbol</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.get_asp_program" href="#pasta.pasta_parser.PastaParser.get_asp_program">get_asp_program</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.get_content_to_compute_minimal_set_facts" href="#pasta.pasta_parser.PastaParser.get_content_to_compute_minimal_set_facts">get_content_to_compute_minimal_set_facts</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.get_functor" href="#pasta.pasta_parser.PastaParser.get_functor">get_functor</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.is_int" href="#pasta.pasta_parser.PastaParser.is_int">is_int</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.is_number" href="#pasta.pasta_parser.PastaParser.is_number">is_number</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.parse" href="#pasta.pasta_parser.PastaParser.parse">parse</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.parse_approx" href="#pasta.pasta_parser.PastaParser.parse_approx">parse_approx</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.parse_program" href="#pasta.pasta_parser.PastaParser.parse_program">parse_program</a></code></li>
<li><code><a title="pasta.pasta_parser.PastaParser.symbol_endline_or_space" href="#pasta.pasta_parser.PastaParser.symbol_endline_or_space">symbol_endline_or_space</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>