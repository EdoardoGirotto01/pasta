<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pasta.asp_interface API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pasta.asp_interface</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import clingo
import time

from models_handler import ModelsHandler


class AspInterface:
        &#39;&#39;&#39;
        Parameters:
                - content: list with the program
        &#39;&#39;&#39;

        def __init__(self, 
                probabilistic_facts : &#39;dict[str,float]&#39;, 
                asp_program : &#39;list[str]&#39;, 
                evidence : str = &#34;&#34;, 
                program_minimal_set : &#39;list[str]&#39; = [], 
                abducibles_list : &#39;list[str]&#39; = [], 
                verbose : bool = False, 
                pedantic : bool = False, 
                n_samples : int = 1000
                ) -&gt; None:
                self.cautious_consequences : list[str] = []
                self.program_minimal_set : list[str] = sorted(set(program_minimal_set))
                self.asp_program : list[str] = sorted(set(asp_program))
                self.lower_probability_query : float = 0
                self.upper_probability_query : float = 0
                self.upper_probability_evidence : float = 0
                self.lower_probability_evidence : float = 0
                self.evidence : str = evidence
                # self.probabilistic_facts = probabilistic_facts # unused
                self.n_prob_facts : int = len(probabilistic_facts) # TODO: is probabilistic_facts used?
                self.abducibles_list : list[str] = abducibles_list
                self.n_abducibles : int = len(self.abducibles_list)
                self.constraint_times_list : list[float] = []
                self.computed_models : int = 0
                self.grounding_time : float = 0
                self.n_worlds : int = 0
                self.world_analysis_time : float = 0
                self.computation_time : float = 0
                self.abductive_explanations : &#39;list[list[str]]&#39; = []
                self.abduction_time : float = 0
                self.verbose : bool = verbose
                self.pedantic : bool = pedantic
                self.n_samples : int = n_samples
                self.prob_facts_dict : dict[str,float] = probabilistic_facts
                self.model_handler : ModelsHandler = \
                        ModelsHandler(
                                self.prob_facts_dict,
                                self.evidence,
                                self.abducibles_list)

        
        def get_minimal_set_facts(self) -&gt; float:
                &#39;&#39;&#39;
                Parameters:
                        - None
                Return:
                        - str
                Behavior:
                        compute the minimal set of facts
                        needed to make the query true. This operation is performed
                        only if there is not evidence.
                        Cautious consequences
                        clingo &lt;filename&gt; -e cautious
                &#39;&#39;&#39;
                ctl = clingo.Control([&#34;--enum-mode=cautious&#34;, &#34;-Wnone&#34;])
                for clause in self.program_minimal_set:
                        ctl.add(&#39;base&#39;,[],clause)

                ctl.ground([(&#34;base&#34;, [])])
                start_time = time.time()

                temp_cautious = []
                with ctl.solve(yield_=True) as handle:  # type: ignore
                        for m in handle:  # type: ignore
                                # i need only the last one
                                temp_cautious = str(m).split(&#39; &#39;)  # type: ignore
                        handle.get()  # type: ignore

                for el in temp_cautious:
                        # if el != &#39;&#39; and (el.split(&#39;,&#39;)[-2] + &#39;)&#39; if el.count(&#39;,&#39;) &gt; 0 else el.split(&#39;(&#39;)[0]) in self.probabilistic_facts:
                        if el != &#39;&#39;:
                                self.cautious_consequences.append(el)

                # sys.exit()
                clingo_time = time.time() - start_time

                return clingo_time


        def compute_probabilities(self) -&gt; None:
                &#39;&#39;&#39;
                Parameters:
                        - None
                Return:
                        - int: number of computed models
                        - float: grounding time
                        - float: computing probability time
                Behavior:
                        compute the lower and upper bound for the query
                        clingo 0 &lt;filename&gt; --project
                &#39;&#39;&#39;
                ctl = clingo.Control([&#34;0&#34;,&#34;--project&#34;,&#34;-Wnone&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;,[],clause)

                if len(self.cautious_consequences) != 0:
                        for c in self.cautious_consequences:
                                ctl.add(&#39;base&#39;,[],&#34;:- not &#34; + c + &#39;.&#39;)
                
                start_time = time.time()
                ctl.ground([(&#34;base&#34;, [])])
                self.grounding_time = time.time() - start_time

                start_time = time.time()

                with ctl.solve(yield_=True) as handle:  # type: ignore
                        for m in handle:  # type: ignore
                                self.model_handler.add_value(str(m))  # type: ignore
                                self.computed_models = self.computed_models + 1
                        handle.get()   # type: ignore
                self.computation_time = time.time() - start_time

                start_time = time.time()
                self.lower_probability_query, self.upper_probability_query = self.model_handler.compute_lower_upper_probability()

                self.n_worlds = self.model_handler.get_number_worlds()

                self.world_analysis_time = time.time() - start_time


        def sample_world(self):
                &#39;&#39;&#39;
                Samples a world for approximate probability computation         
                &#39;&#39;&#39;
                id = &#34;&#34;
                # samples = []
                for key in self.prob_facts_dict:
                        if random.random() &lt; self.prob_facts_dict[key]:
                                id = id + &#34;T&#34;
                                # samples.append(True)
                        else:
                                id = id + &#34;F&#34;
                                # samples.append(False)

                return id


        def pick_random_index(self, block : int, id : str) -&gt; &#39;list[int]&#39;:
                &#39;&#39;&#39;
                Pick a random index, used in Gibbs sampling.
                TODO: this can be a static method.
                &#39;&#39;&#39;
                        # i = random.randint(0,len(id) - 1)
                        # while i == 1:
                        #       i = random.randint(0,len(id) - 1)
                return sorted(set([random.randint(0, len(id) - 1) for _ in range(0, block)]))

        def resample(self, i : int) -&gt; str:
                key : str = &#34;&#34;
                for k in self.prob_facts_dict:
                        key = k
                        i = i - 1
                        if i &lt; 0:
                                break

                if random.random() &lt; self.prob_facts_dict[key]:
                        return &#39;T&#39;
                else:
                        return &#39;F&#39;


        def mh_sampling(self) -&gt; &#39;tuple[float, float]&#39;:
                &#39;&#39;&#39;
                MH sampling
                &#39;&#39;&#39;
                sampled = {}

                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)
                ctl.ground([(&#34;base&#34;, [])])

                n_samples = self.n_samples

                # step 0: build initial sample
                id = self.sample_world()
                t_count = id.count(&#39;T&#39;)
                previous_sampled = t_count if t_count &gt; 0 else 1

                k : int = 0
                n_upper : int = 0
                n_lower : int = 0
                current_sampled : int = 0

                while k &lt; n_samples:
                        id = self.sample_world()

                        if id in sampled:
                                current_sampled = sampled[id][2]

                                if random.random() &lt; min(1, current_sampled/previous_sampled):
                                        k = k + 1
                                        n_upper = n_upper + sampled[id][0]
                                        n_lower = n_lower + sampled[id][1]

                                previous_sampled = current_sampled
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        if atm.is_external:
                                                ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                i = i + 1

                                upper = False
                                lower = True
                                sampled_evidence = False
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                if &#39;e&#39; in m1:
                                                        sampled_evidence = True
                                                        t_count = id.count(&#39;T&#39;)
                                                        current_sampled = t_count if t_count &gt; 0 else 1

                                                        if random.random() &lt; min(1, current_sampled/previous_sampled):
                                                                k = k + 1
                                                                if &#39;q&#39; in m1:
                                                                        upper = True
                                                                if &#34;nq&#34; in m1:
                                                                        lower = False

                                if sampled_evidence is True:
                                        previous_sampled = current_sampled
                                
                                if upper:
                                        n_upper = n_upper + 1
                                        if sampled_evidence is True:
                                                sampled[id] = [1,0,current_sampled]
                                        if lower:
                                                n_lower = n_lower + 1
                                                if sampled_evidence is True:
                                                        sampled[id] = [1,1,current_sampled]

                return n_lower/n_samples, n_upper/n_samples


        def gibbs_sampling(self, block: int) -&gt; &#39;tuple[float, float]&#39;:
                &#39;&#39;&#39;
                Gibbs sampling
                &#39;&#39;&#39;
                # list of samples for the evidence
                sampled_evidence = {}
                # list of samples for the query
                sampled_query = {}

                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)
                ctl.ground([(&#34;base&#34;, [])])

                n_samples = self.n_samples

                n_upper : int = 0
                n_lower : int = 0
                k : int = 0
                ev : bool = False
                id : str = &#34;&#34;
                idNew: str = &#34;&#34;

                while k &lt; n_samples:
                        # Step 0: sample evidence
                        ev = False
                        while ev is False:
                                id = self.sample_world()
                                if id in sampled_evidence:
                                        ev = sampled_evidence[id]
                                else:
                                        i = 0
                                        for atm in ctl.symbolic_atoms:
                                                if atm.is_external:
                                                        ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                        i = i + 1
                                        with ctl.solve(yield_=True) as handle:  # type: ignore
                                                for m in handle:  # type: ignore
                                                        m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                        if &#39;e&#39; in m1:
                                                                ev = True
                                                                break

                                        sampled_evidence[id] = ev

                        k = k + 1

                        # Step 1: switch samples but keep the evidence true
                        ev = False

                        while ev is False:
                                to_resample = self.pick_random_index(block, id)
                                idNew = id
                                # blocked gibbs
                                if idNew in sampled_evidence:
                                        ev = sampled_evidence[idNew]
                                else:
                                        for i in to_resample:
                                                idNew = idNew[:i] + self.resample(i) + idNew[i+1:]

                                        i = 0
                                        for atm in ctl.symbolic_atoms:
                                                if atm.is_external:
                                                        ctl.assign_external(atm.literal, True if idNew[i] == &#39;T&#39; else False)
                                                        i = i + 1
                                        with ctl.solve(yield_=True) as handle:  # type: ignore
                                                for m in handle:  # type: ignore
                                                        m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                        if &#39;e&#39; in m1:
                                                                ev = True
                                                                break
                                                        
                                        sampled_evidence[idNew] = [ev]

                        # step 2: ask query
                        if idNew in sampled_query:
                                n_upper = n_upper + sampled_query[idNew][0]
                                n_lower = n_lower + sampled_query[idNew][1]
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        if atm.is_external:
                                                ctl.assign_external(atm.literal, True if idNew[i] == &#39;T&#39; else False)
                                                i = i + 1

                                upper = False
                                lower = True
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                if &#39;e&#39; in m1:
                                                        if &#39;q&#39; in m1:
                                                                upper = True
                                                        if &#34;nq&#34; in m1:
                                                                lower = False

                                if upper:
                                        n_upper = n_upper + 1
                                        sampled_query[idNew] = [1,0]

                                        if lower:
                                                n_lower = n_lower + 1
                                                sampled_query[idNew] = [1,1]


                return n_lower/n_samples, n_upper/n_samples


        def rejection_sampling(self) -&gt; &#39;tuple[float, float]&#39;:
                &#39;&#39;&#39;
                Rejection Sampling
                &#39;&#39;&#39;
                sampled = {}
                
                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)
                ctl.ground([(&#34;base&#34;, [])])

                n_samples = self.n_samples

                n_upper : int = 0
                n_lower : int = 0
                k : int = 0

                while k &lt; n_samples:
                        ev_sampled = False
                        id = self.sample_world()

                        if id in sampled:
                                k = k + 1
                                n_upper = n_upper + sampled[id][0]
                                n_lower = n_lower + sampled[id][1]
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        if atm.is_external:
                                                ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                i = i + 1

                                upper = False
                                lower = True
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                if &#39;e&#39; in m1:
                                                        ev_sampled = True
                                                        if &#39;q&#39; in m1:
                                                                upper = True
                                                        if &#34;nq&#34; in m1:
                                                                lower = False

                                if ev_sampled is True:
                                        k = k + 1
                                        sampled[id] = [0, 0]

                                if upper is True:
                                        n_upper = n_upper + 1
                                        sampled[id] = [1, 0]
                                        if lower is True:
                                                n_lower = n_lower + 1
                                                sampled[id] = [1, 1]

                return n_lower/n_samples, n_upper/n_samples


        def sample_query(self, bound : bool = False) -&gt; &#39;tuple[float, float]&#39;:
                &#39;&#39;&#39;
                Samples the query self.n_samples times
                If bound is True, stops when either the number of samples taken k
                is greater than self.n_samples or 
                2 * 1.96 * math.sqrt(p * (1-p) / k) &lt; 0.02
                &#39;&#39;&#39;
                # sampled worlds
                sampled = {}
                
                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)
                ctl.ground([(&#34;base&#34;, [])])

                # n_bool_vars = self.n_prob_facts
                n_samples = self.n_samples

                n_upper : int = 0
                n_lower : int = 0
                k : int = 0

                # if bound is True:
                #       import math

                while k &lt; n_samples:
                        id = self.sample_world()

                        if id in sampled:
                                n_upper = n_upper + sampled[id][0]
                                n_lower = n_lower + sampled[id][1]
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        # atm.symbol.name # functor
                                        # atm.symbol.arguments[0].number # index
                                        if atm.is_external:
                                                # possible since dicts are ordered in Python 3.7+
                                                ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                i = i + 1

                                upper = False
                                lower = True
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                if &#34;q&#34; == str(m):  # type: ignore
                                                        upper = True
                                                elif &#34;nq&#34; == str(m):  # type: ignore
                                                        lower = False
                                
                                                handle.get()  # type: ignore

                                if upper:
                                        n_upper = n_upper + 1
                                        sampled[id] = [1, 0]
                                        if lower:
                                                n_lower = n_lower + 1
                                                sampled[id] = [1, 1]
                        k = k + 1
                        
                        # if bound is True:
                        #       p = n_lower / k
                        #       # condition = 2 * 1.96 * math.sqrt(p * (1-p) / k) &gt;= 0.02
                        #       condition = 2 * 1.96 * math.sqrt(p * (1-p) / k) &lt; 0.02  
                        #       if condition and n_lower &gt; 5 and k - n_lower &gt; 5 and k % 101 == 0:
                        #               a = 2 * 1.96 * math.sqrt(p * (1-p) / k)
                        #               break
                
                return n_lower/k, n_upper/k


        def abduction_iter(self, n_abd: int, previously_computed : &#39;list[str]&#39;) -&gt; &#39;tuple[list[str], float]&#39;:
                &#39;&#39;&#39;
                Loop for exact abduction
                &#39;&#39;&#39;
                if self.verbose:
                        print(str(n_abd) + &#34; abd&#34;)

                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)

                if len(self.cautious_consequences) != 0:
                        for c in self.cautious_consequences:
                                ctl.add(&#39;base&#39;, [], &#34;:- not &#34; + c + &#39;.&#39;)

                if self.n_prob_facts == 0:
                        ctl.add(&#39;base&#39;, [], &#39;:- not q.&#39;)
                ctl.add(&#39;base&#39;, [], &#39;abd_facts_counter(C):- #count{X : abd_fact(X)} = C.&#39;)
                ctl.add(&#39;base&#39;, [], &#39;:- abd_facts_counter(C), C != &#39; + str(n_abd) + &#39;.&#39;)
                # TODO: instead of, for each iteration, rewrite the whole program,
                # use multi-shot with Number

                for exp in previously_computed:
                        s = &#34;:- &#34;
                        for el in exp:
                                if el != &#34;q&#34; and not el.startswith(&#39;not_abd&#39;):
                                        s = s + el + &#34;,&#34;
                        s = s[:-1] + &#39;.&#39;
                        ctl.add(&#39;base&#39;, [], s)

                start_time = time.time()
                ctl.ground([(&#34;base&#34;, [])])
                self.grounding_time = time.time() - start_time

                computed_models : list[str] = []

                with ctl.solve(yield_=True) as handle:  # type: ignore
                        for m in handle:  # type: ignore
                                computed_models.append(str(m))  # type: ignore
                                # n_models = n_models + 1
                        handle.get()  # type: ignore

                computation_time = time.time() - start_time

                if self.verbose:
                        print(&#34;time: &#34; + str(computation_time))

                return computed_models, computation_time


        def abduction(self) -&gt; None:
                &#39;&#39;&#39;
                Abduction
                &#39;&#39;&#39;
                computed_abducibles_list : list[str] = []

                start_time = time.time()

                for i in range(0, self.n_abducibles + 1):
                        currently_computed, exec_time = self.abduction_iter(i, computed_abducibles_list)
                        self.computed_models = self.computed_models + len(currently_computed)
                        if self.verbose:
                                print(&#34;Models with &#34; + str(i) + &#34; abducibles: &#34; + str(len(currently_computed)))
                                if self.pedantic:
                                        print(currently_computed)

                        # TODO: gestire len(currently_computed) &gt; 0 and i == 0 (vero senza abducibili)

                        if self.n_prob_facts == 0:
                                # currently computed: list of computed models
                                for i in range(0, len(currently_computed)):
                                        currently_computed[i] = currently_computed[i].split(&#39; &#39;)  # type: ignore
                                        self.abductive_explanations.append(currently_computed[i])  # type: ignore
                                
                                self.computed_models = self.computed_models + len(currently_computed)

                                for cc in currently_computed:
                                        computed_abducibles_list.append(cc)
                        else:
                                for el in currently_computed:
                                        self.model_handler.add_model_abduction(str(el))

                                self.lower_probability_query, self.upper_probability_query = self.model_handler.compute_lower_upper_probability()

                        # keep the best model
                        self.lower_probability_query, self.upper_probability_query = self.model_handler.keep_best_model()
                        self.constraint_times_list.append(exec_time)

                for el in self.model_handler.abd_worlds_dict:
                        self.abductive_explanations.append(self.model_handler.get_abducibles_from_id(el))
                
                self.abduction_time = time.time() - start_time


        def log_infos(self) -&gt; None:
                &#39;&#39;&#39;
                Log some execution details
                &#39;&#39;&#39;
                print(&#34;Computed models: &#34; + str(self.computed_models))
                print(&#34;Considered worlds: &#34; + str(self.n_worlds))
                print(&#34;Grounding time (s): &#34; + str(self.grounding_time))
                print(&#34;Probability computation time (s): &#34; + str(self.computation_time))
                print(&#34;World analysis time (s): &#34; + str(self.world_analysis_time))
        

        def print_asp_program(self) -&gt; None:
                &#39;&#39;&#39;
                Utility that prints the ASP program
                &#39;&#39;&#39;
                for el in self.asp_program:
                        print(el)
                if len(self.cautious_consequences) != 0:
                        for c in self.cautious_consequences:
                                print(&#34;:- not &#34; + c + &#39;.&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pasta.asp_interface.AspInterface"><code class="flex name class">
<span>class <span class="ident">AspInterface</span></span>
<span>(</span><span>probabilistic_facts: dict[str,float], asp_program: list[str], evidence: str = '', program_minimal_set: list[str] = [], abducibles_list: list[str] = [], verbose: bool = False, pedantic: bool = False, n_samples: int = 1000)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li>content: list with the program</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AspInterface:
        &#39;&#39;&#39;
        Parameters:
                - content: list with the program
        &#39;&#39;&#39;

        def __init__(self, 
                probabilistic_facts : &#39;dict[str,float]&#39;, 
                asp_program : &#39;list[str]&#39;, 
                evidence : str = &#34;&#34;, 
                program_minimal_set : &#39;list[str]&#39; = [], 
                abducibles_list : &#39;list[str]&#39; = [], 
                verbose : bool = False, 
                pedantic : bool = False, 
                n_samples : int = 1000
                ) -&gt; None:
                self.cautious_consequences : list[str] = []
                self.program_minimal_set : list[str] = sorted(set(program_minimal_set))
                self.asp_program : list[str] = sorted(set(asp_program))
                self.lower_probability_query : float = 0
                self.upper_probability_query : float = 0
                self.upper_probability_evidence : float = 0
                self.lower_probability_evidence : float = 0
                self.evidence : str = evidence
                # self.probabilistic_facts = probabilistic_facts # unused
                self.n_prob_facts : int = len(probabilistic_facts) # TODO: is probabilistic_facts used?
                self.abducibles_list : list[str] = abducibles_list
                self.n_abducibles : int = len(self.abducibles_list)
                self.constraint_times_list : list[float] = []
                self.computed_models : int = 0
                self.grounding_time : float = 0
                self.n_worlds : int = 0
                self.world_analysis_time : float = 0
                self.computation_time : float = 0
                self.abductive_explanations : &#39;list[list[str]]&#39; = []
                self.abduction_time : float = 0
                self.verbose : bool = verbose
                self.pedantic : bool = pedantic
                self.n_samples : int = n_samples
                self.prob_facts_dict : dict[str,float] = probabilistic_facts
                self.model_handler : ModelsHandler = \
                        ModelsHandler(
                                self.prob_facts_dict,
                                self.evidence,
                                self.abducibles_list)

        
        def get_minimal_set_facts(self) -&gt; float:
                &#39;&#39;&#39;
                Parameters:
                        - None
                Return:
                        - str
                Behavior:
                        compute the minimal set of facts
                        needed to make the query true. This operation is performed
                        only if there is not evidence.
                        Cautious consequences
                        clingo &lt;filename&gt; -e cautious
                &#39;&#39;&#39;
                ctl = clingo.Control([&#34;--enum-mode=cautious&#34;, &#34;-Wnone&#34;])
                for clause in self.program_minimal_set:
                        ctl.add(&#39;base&#39;,[],clause)

                ctl.ground([(&#34;base&#34;, [])])
                start_time = time.time()

                temp_cautious = []
                with ctl.solve(yield_=True) as handle:  # type: ignore
                        for m in handle:  # type: ignore
                                # i need only the last one
                                temp_cautious = str(m).split(&#39; &#39;)  # type: ignore
                        handle.get()  # type: ignore

                for el in temp_cautious:
                        # if el != &#39;&#39; and (el.split(&#39;,&#39;)[-2] + &#39;)&#39; if el.count(&#39;,&#39;) &gt; 0 else el.split(&#39;(&#39;)[0]) in self.probabilistic_facts:
                        if el != &#39;&#39;:
                                self.cautious_consequences.append(el)

                # sys.exit()
                clingo_time = time.time() - start_time

                return clingo_time


        def compute_probabilities(self) -&gt; None:
                &#39;&#39;&#39;
                Parameters:
                        - None
                Return:
                        - int: number of computed models
                        - float: grounding time
                        - float: computing probability time
                Behavior:
                        compute the lower and upper bound for the query
                        clingo 0 &lt;filename&gt; --project
                &#39;&#39;&#39;
                ctl = clingo.Control([&#34;0&#34;,&#34;--project&#34;,&#34;-Wnone&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;,[],clause)

                if len(self.cautious_consequences) != 0:
                        for c in self.cautious_consequences:
                                ctl.add(&#39;base&#39;,[],&#34;:- not &#34; + c + &#39;.&#39;)
                
                start_time = time.time()
                ctl.ground([(&#34;base&#34;, [])])
                self.grounding_time = time.time() - start_time

                start_time = time.time()

                with ctl.solve(yield_=True) as handle:  # type: ignore
                        for m in handle:  # type: ignore
                                self.model_handler.add_value(str(m))  # type: ignore
                                self.computed_models = self.computed_models + 1
                        handle.get()   # type: ignore
                self.computation_time = time.time() - start_time

                start_time = time.time()
                self.lower_probability_query, self.upper_probability_query = self.model_handler.compute_lower_upper_probability()

                self.n_worlds = self.model_handler.get_number_worlds()

                self.world_analysis_time = time.time() - start_time


        def sample_world(self):
                &#39;&#39;&#39;
                Samples a world for approximate probability computation         
                &#39;&#39;&#39;
                id = &#34;&#34;
                # samples = []
                for key in self.prob_facts_dict:
                        if random.random() &lt; self.prob_facts_dict[key]:
                                id = id + &#34;T&#34;
                                # samples.append(True)
                        else:
                                id = id + &#34;F&#34;
                                # samples.append(False)

                return id


        def pick_random_index(self, block : int, id : str) -&gt; &#39;list[int]&#39;:
                &#39;&#39;&#39;
                Pick a random index, used in Gibbs sampling.
                TODO: this can be a static method.
                &#39;&#39;&#39;
                        # i = random.randint(0,len(id) - 1)
                        # while i == 1:
                        #       i = random.randint(0,len(id) - 1)
                return sorted(set([random.randint(0, len(id) - 1) for _ in range(0, block)]))

        def resample(self, i : int) -&gt; str:
                key : str = &#34;&#34;
                for k in self.prob_facts_dict:
                        key = k
                        i = i - 1
                        if i &lt; 0:
                                break

                if random.random() &lt; self.prob_facts_dict[key]:
                        return &#39;T&#39;
                else:
                        return &#39;F&#39;


        def mh_sampling(self) -&gt; &#39;tuple[float, float]&#39;:
                &#39;&#39;&#39;
                MH sampling
                &#39;&#39;&#39;
                sampled = {}

                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)
                ctl.ground([(&#34;base&#34;, [])])

                n_samples = self.n_samples

                # step 0: build initial sample
                id = self.sample_world()
                t_count = id.count(&#39;T&#39;)
                previous_sampled = t_count if t_count &gt; 0 else 1

                k : int = 0
                n_upper : int = 0
                n_lower : int = 0
                current_sampled : int = 0

                while k &lt; n_samples:
                        id = self.sample_world()

                        if id in sampled:
                                current_sampled = sampled[id][2]

                                if random.random() &lt; min(1, current_sampled/previous_sampled):
                                        k = k + 1
                                        n_upper = n_upper + sampled[id][0]
                                        n_lower = n_lower + sampled[id][1]

                                previous_sampled = current_sampled
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        if atm.is_external:
                                                ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                i = i + 1

                                upper = False
                                lower = True
                                sampled_evidence = False
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                if &#39;e&#39; in m1:
                                                        sampled_evidence = True
                                                        t_count = id.count(&#39;T&#39;)
                                                        current_sampled = t_count if t_count &gt; 0 else 1

                                                        if random.random() &lt; min(1, current_sampled/previous_sampled):
                                                                k = k + 1
                                                                if &#39;q&#39; in m1:
                                                                        upper = True
                                                                if &#34;nq&#34; in m1:
                                                                        lower = False

                                if sampled_evidence is True:
                                        previous_sampled = current_sampled
                                
                                if upper:
                                        n_upper = n_upper + 1
                                        if sampled_evidence is True:
                                                sampled[id] = [1,0,current_sampled]
                                        if lower:
                                                n_lower = n_lower + 1
                                                if sampled_evidence is True:
                                                        sampled[id] = [1,1,current_sampled]

                return n_lower/n_samples, n_upper/n_samples


        def gibbs_sampling(self, block: int) -&gt; &#39;tuple[float, float]&#39;:
                &#39;&#39;&#39;
                Gibbs sampling
                &#39;&#39;&#39;
                # list of samples for the evidence
                sampled_evidence = {}
                # list of samples for the query
                sampled_query = {}

                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)
                ctl.ground([(&#34;base&#34;, [])])

                n_samples = self.n_samples

                n_upper : int = 0
                n_lower : int = 0
                k : int = 0
                ev : bool = False
                id : str = &#34;&#34;
                idNew: str = &#34;&#34;

                while k &lt; n_samples:
                        # Step 0: sample evidence
                        ev = False
                        while ev is False:
                                id = self.sample_world()
                                if id in sampled_evidence:
                                        ev = sampled_evidence[id]
                                else:
                                        i = 0
                                        for atm in ctl.symbolic_atoms:
                                                if atm.is_external:
                                                        ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                        i = i + 1
                                        with ctl.solve(yield_=True) as handle:  # type: ignore
                                                for m in handle:  # type: ignore
                                                        m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                        if &#39;e&#39; in m1:
                                                                ev = True
                                                                break

                                        sampled_evidence[id] = ev

                        k = k + 1

                        # Step 1: switch samples but keep the evidence true
                        ev = False

                        while ev is False:
                                to_resample = self.pick_random_index(block, id)
                                idNew = id
                                # blocked gibbs
                                if idNew in sampled_evidence:
                                        ev = sampled_evidence[idNew]
                                else:
                                        for i in to_resample:
                                                idNew = idNew[:i] + self.resample(i) + idNew[i+1:]

                                        i = 0
                                        for atm in ctl.symbolic_atoms:
                                                if atm.is_external:
                                                        ctl.assign_external(atm.literal, True if idNew[i] == &#39;T&#39; else False)
                                                        i = i + 1
                                        with ctl.solve(yield_=True) as handle:  # type: ignore
                                                for m in handle:  # type: ignore
                                                        m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                        if &#39;e&#39; in m1:
                                                                ev = True
                                                                break
                                                        
                                        sampled_evidence[idNew] = [ev]

                        # step 2: ask query
                        if idNew in sampled_query:
                                n_upper = n_upper + sampled_query[idNew][0]
                                n_lower = n_lower + sampled_query[idNew][1]
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        if atm.is_external:
                                                ctl.assign_external(atm.literal, True if idNew[i] == &#39;T&#39; else False)
                                                i = i + 1

                                upper = False
                                lower = True
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                if &#39;e&#39; in m1:
                                                        if &#39;q&#39; in m1:
                                                                upper = True
                                                        if &#34;nq&#34; in m1:
                                                                lower = False

                                if upper:
                                        n_upper = n_upper + 1
                                        sampled_query[idNew] = [1,0]

                                        if lower:
                                                n_lower = n_lower + 1
                                                sampled_query[idNew] = [1,1]


                return n_lower/n_samples, n_upper/n_samples


        def rejection_sampling(self) -&gt; &#39;tuple[float, float]&#39;:
                &#39;&#39;&#39;
                Rejection Sampling
                &#39;&#39;&#39;
                sampled = {}
                
                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)
                ctl.ground([(&#34;base&#34;, [])])

                n_samples = self.n_samples

                n_upper : int = 0
                n_lower : int = 0
                k : int = 0

                while k &lt; n_samples:
                        ev_sampled = False
                        id = self.sample_world()

                        if id in sampled:
                                k = k + 1
                                n_upper = n_upper + sampled[id][0]
                                n_lower = n_lower + sampled[id][1]
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        if atm.is_external:
                                                ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                i = i + 1

                                upper = False
                                lower = True
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                if &#39;e&#39; in m1:
                                                        ev_sampled = True
                                                        if &#39;q&#39; in m1:
                                                                upper = True
                                                        if &#34;nq&#34; in m1:
                                                                lower = False

                                if ev_sampled is True:
                                        k = k + 1
                                        sampled[id] = [0, 0]

                                if upper is True:
                                        n_upper = n_upper + 1
                                        sampled[id] = [1, 0]
                                        if lower is True:
                                                n_lower = n_lower + 1
                                                sampled[id] = [1, 1]

                return n_lower/n_samples, n_upper/n_samples


        def sample_query(self, bound : bool = False) -&gt; &#39;tuple[float, float]&#39;:
                &#39;&#39;&#39;
                Samples the query self.n_samples times
                If bound is True, stops when either the number of samples taken k
                is greater than self.n_samples or 
                2 * 1.96 * math.sqrt(p * (1-p) / k) &lt; 0.02
                &#39;&#39;&#39;
                # sampled worlds
                sampled = {}
                
                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)
                ctl.ground([(&#34;base&#34;, [])])

                # n_bool_vars = self.n_prob_facts
                n_samples = self.n_samples

                n_upper : int = 0
                n_lower : int = 0
                k : int = 0

                # if bound is True:
                #       import math

                while k &lt; n_samples:
                        id = self.sample_world()

                        if id in sampled:
                                n_upper = n_upper + sampled[id][0]
                                n_lower = n_lower + sampled[id][1]
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        # atm.symbol.name # functor
                                        # atm.symbol.arguments[0].number # index
                                        if atm.is_external:
                                                # possible since dicts are ordered in Python 3.7+
                                                ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                i = i + 1

                                upper = False
                                lower = True
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                if &#34;q&#34; == str(m):  # type: ignore
                                                        upper = True
                                                elif &#34;nq&#34; == str(m):  # type: ignore
                                                        lower = False
                                
                                                handle.get()  # type: ignore

                                if upper:
                                        n_upper = n_upper + 1
                                        sampled[id] = [1, 0]
                                        if lower:
                                                n_lower = n_lower + 1
                                                sampled[id] = [1, 1]
                        k = k + 1
                        
                        # if bound is True:
                        #       p = n_lower / k
                        #       # condition = 2 * 1.96 * math.sqrt(p * (1-p) / k) &gt;= 0.02
                        #       condition = 2 * 1.96 * math.sqrt(p * (1-p) / k) &lt; 0.02  
                        #       if condition and n_lower &gt; 5 and k - n_lower &gt; 5 and k % 101 == 0:
                        #               a = 2 * 1.96 * math.sqrt(p * (1-p) / k)
                        #               break
                
                return n_lower/k, n_upper/k


        def abduction_iter(self, n_abd: int, previously_computed : &#39;list[str]&#39;) -&gt; &#39;tuple[list[str], float]&#39;:
                &#39;&#39;&#39;
                Loop for exact abduction
                &#39;&#39;&#39;
                if self.verbose:
                        print(str(n_abd) + &#34; abd&#34;)

                ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
                for clause in self.asp_program:
                        ctl.add(&#39;base&#39;, [], clause)

                if len(self.cautious_consequences) != 0:
                        for c in self.cautious_consequences:
                                ctl.add(&#39;base&#39;, [], &#34;:- not &#34; + c + &#39;.&#39;)

                if self.n_prob_facts == 0:
                        ctl.add(&#39;base&#39;, [], &#39;:- not q.&#39;)
                ctl.add(&#39;base&#39;, [], &#39;abd_facts_counter(C):- #count{X : abd_fact(X)} = C.&#39;)
                ctl.add(&#39;base&#39;, [], &#39;:- abd_facts_counter(C), C != &#39; + str(n_abd) + &#39;.&#39;)
                # TODO: instead of, for each iteration, rewrite the whole program,
                # use multi-shot with Number

                for exp in previously_computed:
                        s = &#34;:- &#34;
                        for el in exp:
                                if el != &#34;q&#34; and not el.startswith(&#39;not_abd&#39;):
                                        s = s + el + &#34;,&#34;
                        s = s[:-1] + &#39;.&#39;
                        ctl.add(&#39;base&#39;, [], s)

                start_time = time.time()
                ctl.ground([(&#34;base&#34;, [])])
                self.grounding_time = time.time() - start_time

                computed_models : list[str] = []

                with ctl.solve(yield_=True) as handle:  # type: ignore
                        for m in handle:  # type: ignore
                                computed_models.append(str(m))  # type: ignore
                                # n_models = n_models + 1
                        handle.get()  # type: ignore

                computation_time = time.time() - start_time

                if self.verbose:
                        print(&#34;time: &#34; + str(computation_time))

                return computed_models, computation_time


        def abduction(self) -&gt; None:
                &#39;&#39;&#39;
                Abduction
                &#39;&#39;&#39;
                computed_abducibles_list : list[str] = []

                start_time = time.time()

                for i in range(0, self.n_abducibles + 1):
                        currently_computed, exec_time = self.abduction_iter(i, computed_abducibles_list)
                        self.computed_models = self.computed_models + len(currently_computed)
                        if self.verbose:
                                print(&#34;Models with &#34; + str(i) + &#34; abducibles: &#34; + str(len(currently_computed)))
                                if self.pedantic:
                                        print(currently_computed)

                        # TODO: gestire len(currently_computed) &gt; 0 and i == 0 (vero senza abducibili)

                        if self.n_prob_facts == 0:
                                # currently computed: list of computed models
                                for i in range(0, len(currently_computed)):
                                        currently_computed[i] = currently_computed[i].split(&#39; &#39;)  # type: ignore
                                        self.abductive_explanations.append(currently_computed[i])  # type: ignore
                                
                                self.computed_models = self.computed_models + len(currently_computed)

                                for cc in currently_computed:
                                        computed_abducibles_list.append(cc)
                        else:
                                for el in currently_computed:
                                        self.model_handler.add_model_abduction(str(el))

                                self.lower_probability_query, self.upper_probability_query = self.model_handler.compute_lower_upper_probability()

                        # keep the best model
                        self.lower_probability_query, self.upper_probability_query = self.model_handler.keep_best_model()
                        self.constraint_times_list.append(exec_time)

                for el in self.model_handler.abd_worlds_dict:
                        self.abductive_explanations.append(self.model_handler.get_abducibles_from_id(el))
                
                self.abduction_time = time.time() - start_time


        def log_infos(self) -&gt; None:
                &#39;&#39;&#39;
                Log some execution details
                &#39;&#39;&#39;
                print(&#34;Computed models: &#34; + str(self.computed_models))
                print(&#34;Considered worlds: &#34; + str(self.n_worlds))
                print(&#34;Grounding time (s): &#34; + str(self.grounding_time))
                print(&#34;Probability computation time (s): &#34; + str(self.computation_time))
                print(&#34;World analysis time (s): &#34; + str(self.world_analysis_time))
        

        def print_asp_program(self) -&gt; None:
                &#39;&#39;&#39;
                Utility that prints the ASP program
                &#39;&#39;&#39;
                for el in self.asp_program:
                        print(el)
                if len(self.cautious_consequences) != 0:
                        for c in self.cautious_consequences:
                                print(&#34;:- not &#34; + c + &#39;.&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pasta.asp_interface.AspInterface.abduction"><code class="name flex">
<span>def <span class="ident">abduction</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Abduction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abduction(self) -&gt; None:
        &#39;&#39;&#39;
        Abduction
        &#39;&#39;&#39;
        computed_abducibles_list : list[str] = []

        start_time = time.time()

        for i in range(0, self.n_abducibles + 1):
                currently_computed, exec_time = self.abduction_iter(i, computed_abducibles_list)
                self.computed_models = self.computed_models + len(currently_computed)
                if self.verbose:
                        print(&#34;Models with &#34; + str(i) + &#34; abducibles: &#34; + str(len(currently_computed)))
                        if self.pedantic:
                                print(currently_computed)

                # TODO: gestire len(currently_computed) &gt; 0 and i == 0 (vero senza abducibili)

                if self.n_prob_facts == 0:
                        # currently computed: list of computed models
                        for i in range(0, len(currently_computed)):
                                currently_computed[i] = currently_computed[i].split(&#39; &#39;)  # type: ignore
                                self.abductive_explanations.append(currently_computed[i])  # type: ignore
                        
                        self.computed_models = self.computed_models + len(currently_computed)

                        for cc in currently_computed:
                                computed_abducibles_list.append(cc)
                else:
                        for el in currently_computed:
                                self.model_handler.add_model_abduction(str(el))

                        self.lower_probability_query, self.upper_probability_query = self.model_handler.compute_lower_upper_probability()

                # keep the best model
                self.lower_probability_query, self.upper_probability_query = self.model_handler.keep_best_model()
                self.constraint_times_list.append(exec_time)

        for el in self.model_handler.abd_worlds_dict:
                self.abductive_explanations.append(self.model_handler.get_abducibles_from_id(el))
        
        self.abduction_time = time.time() - start_time</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.abduction_iter"><code class="name flex">
<span>def <span class="ident">abduction_iter</span></span>(<span>self, n_abd: int, previously_computed: list[str]) ‑> tuple[list[str], float]</span>
</code></dt>
<dd>
<div class="desc"><p>Loop for exact abduction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abduction_iter(self, n_abd: int, previously_computed : &#39;list[str]&#39;) -&gt; &#39;tuple[list[str], float]&#39;:
        &#39;&#39;&#39;
        Loop for exact abduction
        &#39;&#39;&#39;
        if self.verbose:
                print(str(n_abd) + &#34; abd&#34;)

        ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
        for clause in self.asp_program:
                ctl.add(&#39;base&#39;, [], clause)

        if len(self.cautious_consequences) != 0:
                for c in self.cautious_consequences:
                        ctl.add(&#39;base&#39;, [], &#34;:- not &#34; + c + &#39;.&#39;)

        if self.n_prob_facts == 0:
                ctl.add(&#39;base&#39;, [], &#39;:- not q.&#39;)
        ctl.add(&#39;base&#39;, [], &#39;abd_facts_counter(C):- #count{X : abd_fact(X)} = C.&#39;)
        ctl.add(&#39;base&#39;, [], &#39;:- abd_facts_counter(C), C != &#39; + str(n_abd) + &#39;.&#39;)
        # TODO: instead of, for each iteration, rewrite the whole program,
        # use multi-shot with Number

        for exp in previously_computed:
                s = &#34;:- &#34;
                for el in exp:
                        if el != &#34;q&#34; and not el.startswith(&#39;not_abd&#39;):
                                s = s + el + &#34;,&#34;
                s = s[:-1] + &#39;.&#39;
                ctl.add(&#39;base&#39;, [], s)

        start_time = time.time()
        ctl.ground([(&#34;base&#34;, [])])
        self.grounding_time = time.time() - start_time

        computed_models : list[str] = []

        with ctl.solve(yield_=True) as handle:  # type: ignore
                for m in handle:  # type: ignore
                        computed_models.append(str(m))  # type: ignore
                        # n_models = n_models + 1
                handle.get()  # type: ignore

        computation_time = time.time() - start_time

        if self.verbose:
                print(&#34;time: &#34; + str(computation_time))

        return computed_models, computation_time</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.compute_probabilities"><code class="name flex">
<span>def <span class="ident">compute_probabilities</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li>None</li>
</ul>
<h2 id="return">Return</h2>
<ul>
<li>int: number of computed models</li>
<li>float: grounding time</li>
<li>float: computing probability time</li>
</ul>
<h2 id="behavior">Behavior</h2>
<p>compute the lower and upper bound for the query
clingo 0 <filename> &ndash;project</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_probabilities(self) -&gt; None:
        &#39;&#39;&#39;
        Parameters:
                - None
        Return:
                - int: number of computed models
                - float: grounding time
                - float: computing probability time
        Behavior:
                compute the lower and upper bound for the query
                clingo 0 &lt;filename&gt; --project
        &#39;&#39;&#39;
        ctl = clingo.Control([&#34;0&#34;,&#34;--project&#34;,&#34;-Wnone&#34;])
        for clause in self.asp_program:
                ctl.add(&#39;base&#39;,[],clause)

        if len(self.cautious_consequences) != 0:
                for c in self.cautious_consequences:
                        ctl.add(&#39;base&#39;,[],&#34;:- not &#34; + c + &#39;.&#39;)
        
        start_time = time.time()
        ctl.ground([(&#34;base&#34;, [])])
        self.grounding_time = time.time() - start_time

        start_time = time.time()

        with ctl.solve(yield_=True) as handle:  # type: ignore
                for m in handle:  # type: ignore
                        self.model_handler.add_value(str(m))  # type: ignore
                        self.computed_models = self.computed_models + 1
                handle.get()   # type: ignore
        self.computation_time = time.time() - start_time

        start_time = time.time()
        self.lower_probability_query, self.upper_probability_query = self.model_handler.compute_lower_upper_probability()

        self.n_worlds = self.model_handler.get_number_worlds()

        self.world_analysis_time = time.time() - start_time</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.get_minimal_set_facts"><code class="name flex">
<span>def <span class="ident">get_minimal_set_facts</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li>None</li>
</ul>
<h2 id="return">Return</h2>
<ul>
<li>str</li>
</ul>
<h2 id="behavior">Behavior</h2>
<p>compute the minimal set of facts
needed to make the query true. This operation is performed
only if there is not evidence.
Cautious consequences
clingo <filename> -e cautious</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_minimal_set_facts(self) -&gt; float:
        &#39;&#39;&#39;
        Parameters:
                - None
        Return:
                - str
        Behavior:
                compute the minimal set of facts
                needed to make the query true. This operation is performed
                only if there is not evidence.
                Cautious consequences
                clingo &lt;filename&gt; -e cautious
        &#39;&#39;&#39;
        ctl = clingo.Control([&#34;--enum-mode=cautious&#34;, &#34;-Wnone&#34;])
        for clause in self.program_minimal_set:
                ctl.add(&#39;base&#39;,[],clause)

        ctl.ground([(&#34;base&#34;, [])])
        start_time = time.time()

        temp_cautious = []
        with ctl.solve(yield_=True) as handle:  # type: ignore
                for m in handle:  # type: ignore
                        # i need only the last one
                        temp_cautious = str(m).split(&#39; &#39;)  # type: ignore
                handle.get()  # type: ignore

        for el in temp_cautious:
                # if el != &#39;&#39; and (el.split(&#39;,&#39;)[-2] + &#39;)&#39; if el.count(&#39;,&#39;) &gt; 0 else el.split(&#39;(&#39;)[0]) in self.probabilistic_facts:
                if el != &#39;&#39;:
                        self.cautious_consequences.append(el)

        # sys.exit()
        clingo_time = time.time() - start_time

        return clingo_time</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.gibbs_sampling"><code class="name flex">
<span>def <span class="ident">gibbs_sampling</span></span>(<span>self, block: int) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Gibbs sampling</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gibbs_sampling(self, block: int) -&gt; &#39;tuple[float, float]&#39;:
        &#39;&#39;&#39;
        Gibbs sampling
        &#39;&#39;&#39;
        # list of samples for the evidence
        sampled_evidence = {}
        # list of samples for the query
        sampled_query = {}

        ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
        for clause in self.asp_program:
                ctl.add(&#39;base&#39;, [], clause)
        ctl.ground([(&#34;base&#34;, [])])

        n_samples = self.n_samples

        n_upper : int = 0
        n_lower : int = 0
        k : int = 0
        ev : bool = False
        id : str = &#34;&#34;
        idNew: str = &#34;&#34;

        while k &lt; n_samples:
                # Step 0: sample evidence
                ev = False
                while ev is False:
                        id = self.sample_world()
                        if id in sampled_evidence:
                                ev = sampled_evidence[id]
                        else:
                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        if atm.is_external:
                                                ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                                i = i + 1
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                if &#39;e&#39; in m1:
                                                        ev = True
                                                        break

                                sampled_evidence[id] = ev

                k = k + 1

                # Step 1: switch samples but keep the evidence true
                ev = False

                while ev is False:
                        to_resample = self.pick_random_index(block, id)
                        idNew = id
                        # blocked gibbs
                        if idNew in sampled_evidence:
                                ev = sampled_evidence[idNew]
                        else:
                                for i in to_resample:
                                        idNew = idNew[:i] + self.resample(i) + idNew[i+1:]

                                i = 0
                                for atm in ctl.symbolic_atoms:
                                        if atm.is_external:
                                                ctl.assign_external(atm.literal, True if idNew[i] == &#39;T&#39; else False)
                                                i = i + 1
                                with ctl.solve(yield_=True) as handle:  # type: ignore
                                        for m in handle:  # type: ignore
                                                m1 = str(m).split(&#39; &#39;)  # type: ignore
                                                if &#39;e&#39; in m1:
                                                        ev = True
                                                        break
                                                
                                sampled_evidence[idNew] = [ev]

                # step 2: ask query
                if idNew in sampled_query:
                        n_upper = n_upper + sampled_query[idNew][0]
                        n_lower = n_lower + sampled_query[idNew][1]
                else:
                        i = 0
                        for atm in ctl.symbolic_atoms:
                                if atm.is_external:
                                        ctl.assign_external(atm.literal, True if idNew[i] == &#39;T&#39; else False)
                                        i = i + 1

                        upper = False
                        lower = True
                        with ctl.solve(yield_=True) as handle:  # type: ignore
                                for m in handle:  # type: ignore
                                        m1 = str(m).split(&#39; &#39;)  # type: ignore
                                        if &#39;e&#39; in m1:
                                                if &#39;q&#39; in m1:
                                                        upper = True
                                                if &#34;nq&#34; in m1:
                                                        lower = False

                        if upper:
                                n_upper = n_upper + 1
                                sampled_query[idNew] = [1,0]

                                if lower:
                                        n_lower = n_lower + 1
                                        sampled_query[idNew] = [1,1]


        return n_lower/n_samples, n_upper/n_samples</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.log_infos"><code class="name flex">
<span>def <span class="ident">log_infos</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Log some execution details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_infos(self) -&gt; None:
        &#39;&#39;&#39;
        Log some execution details
        &#39;&#39;&#39;
        print(&#34;Computed models: &#34; + str(self.computed_models))
        print(&#34;Considered worlds: &#34; + str(self.n_worlds))
        print(&#34;Grounding time (s): &#34; + str(self.grounding_time))
        print(&#34;Probability computation time (s): &#34; + str(self.computation_time))
        print(&#34;World analysis time (s): &#34; + str(self.world_analysis_time))</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.mh_sampling"><code class="name flex">
<span>def <span class="ident">mh_sampling</span></span>(<span>self) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>MH sampling</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mh_sampling(self) -&gt; &#39;tuple[float, float]&#39;:
        &#39;&#39;&#39;
        MH sampling
        &#39;&#39;&#39;
        sampled = {}

        ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
        for clause in self.asp_program:
                ctl.add(&#39;base&#39;, [], clause)
        ctl.ground([(&#34;base&#34;, [])])

        n_samples = self.n_samples

        # step 0: build initial sample
        id = self.sample_world()
        t_count = id.count(&#39;T&#39;)
        previous_sampled = t_count if t_count &gt; 0 else 1

        k : int = 0
        n_upper : int = 0
        n_lower : int = 0
        current_sampled : int = 0

        while k &lt; n_samples:
                id = self.sample_world()

                if id in sampled:
                        current_sampled = sampled[id][2]

                        if random.random() &lt; min(1, current_sampled/previous_sampled):
                                k = k + 1
                                n_upper = n_upper + sampled[id][0]
                                n_lower = n_lower + sampled[id][1]

                        previous_sampled = current_sampled
                else:
                        i = 0
                        for atm in ctl.symbolic_atoms:
                                if atm.is_external:
                                        ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                        i = i + 1

                        upper = False
                        lower = True
                        sampled_evidence = False
                        with ctl.solve(yield_=True) as handle:  # type: ignore
                                for m in handle:  # type: ignore
                                        m1 = str(m).split(&#39; &#39;)  # type: ignore
                                        if &#39;e&#39; in m1:
                                                sampled_evidence = True
                                                t_count = id.count(&#39;T&#39;)
                                                current_sampled = t_count if t_count &gt; 0 else 1

                                                if random.random() &lt; min(1, current_sampled/previous_sampled):
                                                        k = k + 1
                                                        if &#39;q&#39; in m1:
                                                                upper = True
                                                        if &#34;nq&#34; in m1:
                                                                lower = False

                        if sampled_evidence is True:
                                previous_sampled = current_sampled
                        
                        if upper:
                                n_upper = n_upper + 1
                                if sampled_evidence is True:
                                        sampled[id] = [1,0,current_sampled]
                                if lower:
                                        n_lower = n_lower + 1
                                        if sampled_evidence is True:
                                                sampled[id] = [1,1,current_sampled]

        return n_lower/n_samples, n_upper/n_samples</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.pick_random_index"><code class="name flex">
<span>def <span class="ident">pick_random_index</span></span>(<span>self, block: int, id: str) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Pick a random index, used in Gibbs sampling.
TODO: this can be a static method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pick_random_index(self, block : int, id : str) -&gt; &#39;list[int]&#39;:
        &#39;&#39;&#39;
        Pick a random index, used in Gibbs sampling.
        TODO: this can be a static method.
        &#39;&#39;&#39;
                # i = random.randint(0,len(id) - 1)
                # while i == 1:
                #       i = random.randint(0,len(id) - 1)
        return sorted(set([random.randint(0, len(id) - 1) for _ in range(0, block)]))</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.print_asp_program"><code class="name flex">
<span>def <span class="ident">print_asp_program</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Utility that prints the ASP program</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_asp_program(self) -&gt; None:
        &#39;&#39;&#39;
        Utility that prints the ASP program
        &#39;&#39;&#39;
        for el in self.asp_program:
                print(el)
        if len(self.cautious_consequences) != 0:
                for c in self.cautious_consequences:
                        print(&#34;:- not &#34; + c + &#39;.&#39;)</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.rejection_sampling"><code class="name flex">
<span>def <span class="ident">rejection_sampling</span></span>(<span>self) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Rejection Sampling</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rejection_sampling(self) -&gt; &#39;tuple[float, float]&#39;:
        &#39;&#39;&#39;
        Rejection Sampling
        &#39;&#39;&#39;
        sampled = {}
        
        ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
        for clause in self.asp_program:
                ctl.add(&#39;base&#39;, [], clause)
        ctl.ground([(&#34;base&#34;, [])])

        n_samples = self.n_samples

        n_upper : int = 0
        n_lower : int = 0
        k : int = 0

        while k &lt; n_samples:
                ev_sampled = False
                id = self.sample_world()

                if id in sampled:
                        k = k + 1
                        n_upper = n_upper + sampled[id][0]
                        n_lower = n_lower + sampled[id][1]
                else:
                        i = 0
                        for atm in ctl.symbolic_atoms:
                                if atm.is_external:
                                        ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                        i = i + 1

                        upper = False
                        lower = True
                        with ctl.solve(yield_=True) as handle:  # type: ignore
                                for m in handle:  # type: ignore
                                        m1 = str(m).split(&#39; &#39;)  # type: ignore
                                        if &#39;e&#39; in m1:
                                                ev_sampled = True
                                                if &#39;q&#39; in m1:
                                                        upper = True
                                                if &#34;nq&#34; in m1:
                                                        lower = False

                        if ev_sampled is True:
                                k = k + 1
                                sampled[id] = [0, 0]

                        if upper is True:
                                n_upper = n_upper + 1
                                sampled[id] = [1, 0]
                                if lower is True:
                                        n_lower = n_lower + 1
                                        sampled[id] = [1, 1]

        return n_lower/n_samples, n_upper/n_samples</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>self, i: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resample(self, i : int) -&gt; str:
        key : str = &#34;&#34;
        for k in self.prob_facts_dict:
                key = k
                i = i - 1
                if i &lt; 0:
                        break

        if random.random() &lt; self.prob_facts_dict[key]:
                return &#39;T&#39;
        else:
                return &#39;F&#39;</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.sample_query"><code class="name flex">
<span>def <span class="ident">sample_query</span></span>(<span>self, bound: bool = False) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Samples the query self.n_samples times
If bound is True, stops when either the number of samples taken k
is greater than self.n_samples or
2 * 1.96 * math.sqrt(p * (1-p) / k) &lt; 0.02</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_query(self, bound : bool = False) -&gt; &#39;tuple[float, float]&#39;:
        &#39;&#39;&#39;
        Samples the query self.n_samples times
        If bound is True, stops when either the number of samples taken k
        is greater than self.n_samples or 
        2 * 1.96 * math.sqrt(p * (1-p) / k) &lt; 0.02
        &#39;&#39;&#39;
        # sampled worlds
        sampled = {}
        
        ctl = clingo.Control([&#34;0&#34;, &#34;--project&#34;])
        for clause in self.asp_program:
                ctl.add(&#39;base&#39;, [], clause)
        ctl.ground([(&#34;base&#34;, [])])

        # n_bool_vars = self.n_prob_facts
        n_samples = self.n_samples

        n_upper : int = 0
        n_lower : int = 0
        k : int = 0

        # if bound is True:
        #       import math

        while k &lt; n_samples:
                id = self.sample_world()

                if id in sampled:
                        n_upper = n_upper + sampled[id][0]
                        n_lower = n_lower + sampled[id][1]
                else:
                        i = 0
                        for atm in ctl.symbolic_atoms:
                                # atm.symbol.name # functor
                                # atm.symbol.arguments[0].number # index
                                if atm.is_external:
                                        # possible since dicts are ordered in Python 3.7+
                                        ctl.assign_external(atm.literal, True if id[i] == &#39;T&#39; else False)
                                        i = i + 1

                        upper = False
                        lower = True
                        with ctl.solve(yield_=True) as handle:  # type: ignore
                                for m in handle:  # type: ignore
                                        if &#34;q&#34; == str(m):  # type: ignore
                                                upper = True
                                        elif &#34;nq&#34; == str(m):  # type: ignore
                                                lower = False
                        
                                        handle.get()  # type: ignore

                        if upper:
                                n_upper = n_upper + 1
                                sampled[id] = [1, 0]
                                if lower:
                                        n_lower = n_lower + 1
                                        sampled[id] = [1, 1]
                k = k + 1
                
                # if bound is True:
                #       p = n_lower / k
                #       # condition = 2 * 1.96 * math.sqrt(p * (1-p) / k) &gt;= 0.02
                #       condition = 2 * 1.96 * math.sqrt(p * (1-p) / k) &lt; 0.02  
                #       if condition and n_lower &gt; 5 and k - n_lower &gt; 5 and k % 101 == 0:
                #               a = 2 * 1.96 * math.sqrt(p * (1-p) / k)
                #               break
        
        return n_lower/k, n_upper/k</code></pre>
</details>
</dd>
<dt id="pasta.asp_interface.AspInterface.sample_world"><code class="name flex">
<span>def <span class="ident">sample_world</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Samples a world for approximate probability computation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_world(self):
        &#39;&#39;&#39;
        Samples a world for approximate probability computation         
        &#39;&#39;&#39;
        id = &#34;&#34;
        # samples = []
        for key in self.prob_facts_dict:
                if random.random() &lt; self.prob_facts_dict[key]:
                        id = id + &#34;T&#34;
                        # samples.append(True)
                else:
                        id = id + &#34;F&#34;
                        # samples.append(False)

        return id</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pasta" href="index.html">pasta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pasta.asp_interface.AspInterface" href="#pasta.asp_interface.AspInterface">AspInterface</a></code></h4>
<ul class="">
<li><code><a title="pasta.asp_interface.AspInterface.abduction" href="#pasta.asp_interface.AspInterface.abduction">abduction</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.abduction_iter" href="#pasta.asp_interface.AspInterface.abduction_iter">abduction_iter</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.compute_probabilities" href="#pasta.asp_interface.AspInterface.compute_probabilities">compute_probabilities</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.get_minimal_set_facts" href="#pasta.asp_interface.AspInterface.get_minimal_set_facts">get_minimal_set_facts</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.gibbs_sampling" href="#pasta.asp_interface.AspInterface.gibbs_sampling">gibbs_sampling</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.log_infos" href="#pasta.asp_interface.AspInterface.log_infos">log_infos</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.mh_sampling" href="#pasta.asp_interface.AspInterface.mh_sampling">mh_sampling</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.pick_random_index" href="#pasta.asp_interface.AspInterface.pick_random_index">pick_random_index</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.print_asp_program" href="#pasta.asp_interface.AspInterface.print_asp_program">print_asp_program</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.rejection_sampling" href="#pasta.asp_interface.AspInterface.rejection_sampling">rejection_sampling</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.resample" href="#pasta.asp_interface.AspInterface.resample">resample</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.sample_query" href="#pasta.asp_interface.AspInterface.sample_query">sample_query</a></code></li>
<li><code><a title="pasta.asp_interface.AspInterface.sample_world" href="#pasta.asp_interface.AspInterface.sample_world">sample_world</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>